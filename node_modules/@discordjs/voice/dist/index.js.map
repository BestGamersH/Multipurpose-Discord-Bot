{"version":3,"sources":["../src/index.ts","../src/DataStore.ts","../src/networking/Networking.ts","../src/networking/VoiceUDPSocket.ts","../src/networking/VoiceWebSocket.ts","../src/util/Secretbox.ts","../src/util/util.ts","../src/VoiceConnection.ts","../src/receive/VoiceReceiver.ts","../src/receive/AudioReceiveStream.ts","../src/audio/AudioPlayerError.ts","../src/audio/PlayerSubscription.ts","../src/audio/AudioPlayer.ts","../src/receive/SpeakingMap.ts","../src/receive/SSRCMap.ts","../src/joinVoiceChannel.ts","../src/audio/TransformerGraph.ts","../src/audio/AudioResource.ts","../src/util/generateDependencyReport.ts","../src/util/abortAfter.ts","../src/util/entersState.ts","../src/util/demuxProbe.ts"],"sourcesContent":["export * from './joinVoiceChannel';\nexport * from './audio';\nexport * from './util';\nexport * from './receive';\n\nexport {\n\tVoiceConnection,\n\tVoiceConnectionState,\n\tVoiceConnectionStatus,\n\tVoiceConnectionConnectingState,\n\tVoiceConnectionDestroyedState,\n\tVoiceConnectionDisconnectedState,\n\tVoiceConnectionDisconnectedBaseState,\n\tVoiceConnectionDisconnectedOtherState,\n\tVoiceConnectionDisconnectedWebSocketState,\n\tVoiceConnectionDisconnectReason,\n\tVoiceConnectionReadyState,\n\tVoiceConnectionSignallingState,\n\tVoiceConnectionEvents,\n} from './VoiceConnection';\n\nexport { JoinConfig, getVoiceConnection, getVoiceConnections, getGroups } from './DataStore';\n","import { GatewayOpcodes } from 'discord-api-types/v9';\nimport type { AudioPlayer } from './audio';\nimport type { VoiceConnection } from './VoiceConnection';\n\nexport interface JoinConfig {\n\tguildId: string;\n\tchannelId: string | null;\n\tselfDeaf: boolean;\n\tselfMute: boolean;\n\tgroup: string;\n}\n\n/**\n * Sends a voice state update to the main websocket shard of a guild, to indicate joining/leaving/moving across\n * voice channels.\n *\n * @param config - The configuration to use when joining the voice channel\n */\nexport function createJoinVoiceChannelPayload(config: JoinConfig) {\n\treturn {\n\t\top: GatewayOpcodes.VoiceStateUpdate,\n\t\td: {\n\t\t\tguild_id: config.guildId,\n\t\t\tchannel_id: config.channelId,\n\t\t\tself_deaf: config.selfDeaf,\n\t\t\tself_mute: config.selfMute,\n\t\t},\n\t};\n}\n\n// Voice Connections\nconst groups = new Map<string, Map<string, VoiceConnection>>();\ngroups.set('default', new Map());\n\nfunction getOrCreateGroup(group: string) {\n\tconst existing = groups.get(group);\n\tif (existing) return existing;\n\tconst map = new Map<string, VoiceConnection>();\n\tgroups.set(group, map);\n\treturn map;\n}\n\n/**\n * Retrieves the map of group names to maps of voice connections. By default, all voice connections\n * are created under the 'default' group.\n *\n * @returns The group map\n */\nexport function getGroups() {\n\treturn groups;\n}\n\n/**\n * Retrieves all the voice connections under the 'default' group.\n *\n * @param group - The group to look up\n *\n * @returns The map of voice connections\n */\nexport function getVoiceConnections(group?: 'default'): Map<string, VoiceConnection>;\n\n/**\n * Retrieves all the voice connections under the given group name.\n *\n * @param group - The group to look up\n *\n * @returns The map of voice connections\n */\nexport function getVoiceConnections(group: string): Map<string, VoiceConnection> | undefined;\n\n/**\n * Retrieves all the voice connections under the given group name. Defaults to the 'default' group.\n *\n * @param group - The group to look up\n *\n * @returns The map of voice connections\n */\nexport function getVoiceConnections(group = 'default') {\n\treturn groups.get(group);\n}\n\n/**\n * Finds a voice connection with the given guild id and group. Defaults to the 'default' group.\n *\n * @param guildId - The guild id of the voice connection\n * @param group - the group that the voice connection was registered with\n *\n * @returns The voice connection, if it exists\n */\nexport function getVoiceConnection(guildId: string, group = 'default') {\n\treturn getVoiceConnections(group)?.get(guildId);\n}\n\nexport function untrackVoiceConnection(voiceConnection: VoiceConnection) {\n\treturn getVoiceConnections(voiceConnection.joinConfig.group)?.delete(voiceConnection.joinConfig.guildId);\n}\n\nexport function trackVoiceConnection(voiceConnection: VoiceConnection) {\n\treturn getOrCreateGroup(voiceConnection.joinConfig.group).set(voiceConnection.joinConfig.guildId, voiceConnection);\n}\n\n// Audio Players\n\n// Each audio packet is 20ms long\nconst FRAME_LENGTH = 20;\n\nlet audioCycleInterval: NodeJS.Timeout | undefined;\nlet nextTime = -1;\n\n/**\n * A list of created audio players that are still active and haven't been destroyed.\n */\nconst audioPlayers: AudioPlayer[] = [];\n\n/**\n * Called roughly every 20 milliseconds. Dispatches audio from all players, and then gets the players to prepare\n * the next audio frame.\n */\nfunction audioCycleStep() {\n\tif (nextTime === -1) return;\n\n\tnextTime += FRAME_LENGTH;\n\tconst available = audioPlayers.filter((player) => player.checkPlayable());\n\n\t// eslint-disable-next-line @typescript-eslint/dot-notation\n\tavailable.forEach((player) => player['_stepDispatch']());\n\n\t// eslint-disable-next-line @typescript-eslint/no-use-before-define\n\tprepareNextAudioFrame(available);\n}\n\n/**\n * Recursively gets the players that have been passed as parameters to prepare audio frames that can be played\n * at the start of the next cycle.\n */\nfunction prepareNextAudioFrame(players: AudioPlayer[]) {\n\tconst nextPlayer = players.shift();\n\n\tif (!nextPlayer) {\n\t\tif (nextTime !== -1) {\n\t\t\taudioCycleInterval = setTimeout(() => audioCycleStep(), nextTime - Date.now());\n\t\t}\n\t\treturn;\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/dot-notation\n\tnextPlayer['_stepPrepare']();\n\n\t// setImmediate to avoid long audio player chains blocking other scheduled tasks\n\tsetImmediate(() => prepareNextAudioFrame(players));\n}\n\n/**\n * Checks whether or not the given audio player is being driven by the data store clock.\n *\n * @param target - The target to test for\n *\n * @returns `true` if it is being tracked, `false` otherwise\n */\nexport function hasAudioPlayer(target: AudioPlayer) {\n\treturn audioPlayers.includes(target);\n}\n\n/**\n * Adds an audio player to the data store tracking list, if it isn't already there.\n *\n * @param player - The player to track\n */\nexport function addAudioPlayer(player: AudioPlayer) {\n\tif (hasAudioPlayer(player)) return player;\n\taudioPlayers.push(player);\n\tif (audioPlayers.length === 1) {\n\t\tnextTime = Date.now();\n\t\tsetImmediate(() => audioCycleStep());\n\t}\n\treturn player;\n}\n\n/**\n * Removes an audio player from the data store tracking list, if it is present there.\n */\nexport function deleteAudioPlayer(player: AudioPlayer) {\n\tconst index = audioPlayers.indexOf(player);\n\tif (index === -1) return;\n\taudioPlayers.splice(index, 1);\n\tif (audioPlayers.length === 0) {\n\t\tnextTime = -1;\n\t\tif (typeof audioCycleInterval !== 'undefined') clearTimeout(audioCycleInterval);\n\t}\n}\n","import { VoiceOpcodes } from 'discord-api-types/voice/v4';\nimport { VoiceUDPSocket } from './VoiceUDPSocket';\nimport { VoiceWebSocket } from './VoiceWebSocket';\nimport * as secretbox from '../util/Secretbox';\nimport { Awaited, noop } from '../util/util';\nimport type { CloseEvent } from 'ws';\nimport { TypedEmitter } from 'tiny-typed-emitter';\n\n// The number of audio channels required by Discord\nconst CHANNELS = 2;\nconst TIMESTAMP_INC = (48000 / 100) * CHANNELS;\nconst MAX_NONCE_SIZE = 2 ** 32 - 1;\n\nexport const SUPPORTED_ENCRYPTION_MODES = ['xsalsa20_poly1305_lite', 'xsalsa20_poly1305_suffix', 'xsalsa20_poly1305'];\n\n/**\n * The different statuses that a networking instance can hold. The order\n * of the states between OpeningWs and Ready is chronological (first the\n * instance enters OpeningWs, then it enters Identifying etc.)\n */\nexport enum NetworkingStatusCode {\n\tOpeningWs,\n\tIdentifying,\n\tUdpHandshaking,\n\tSelectingProtocol,\n\tReady,\n\tResuming,\n\tClosed,\n}\n\n/**\n * The initial Networking state. Instances will be in this state when a WebSocket connection to a Discord\n * voice gateway is being opened.\n */\nexport interface NetworkingOpeningWsState {\n\tcode: NetworkingStatusCode.OpeningWs;\n\tws: VoiceWebSocket;\n\tconnectionOptions: ConnectionOptions;\n}\n\n/**\n * The state that a Networking instance will be in when it is attempting to authorize itself.\n */\nexport interface NetworkingIdentifyingState {\n\tcode: NetworkingStatusCode.Identifying;\n\tws: VoiceWebSocket;\n\tconnectionOptions: ConnectionOptions;\n}\n\n/**\n * The state that a Networking instance will be in when opening a UDP connection to the IP and port provided\n * by Discord, as well as performing IP discovery.\n */\nexport interface NetworkingUdpHandshakingState {\n\tcode: NetworkingStatusCode.UdpHandshaking;\n\tws: VoiceWebSocket;\n\tudp: VoiceUDPSocket;\n\tconnectionOptions: ConnectionOptions;\n\tconnectionData: Pick<ConnectionData, 'ssrc'>;\n}\n\n/**\n * The state that a Networking instance will be in when selecting an encryption protocol for audio packets.\n */\nexport interface NetworkingSelectingProtocolState {\n\tcode: NetworkingStatusCode.SelectingProtocol;\n\tws: VoiceWebSocket;\n\tudp: VoiceUDPSocket;\n\tconnectionOptions: ConnectionOptions;\n\tconnectionData: Pick<ConnectionData, 'ssrc'>;\n}\n\n/**\n * The state that a Networking instance will be in when it has a fully established connection to a Discord\n * voice server.\n */\nexport interface NetworkingReadyState {\n\tcode: NetworkingStatusCode.Ready;\n\tws: VoiceWebSocket;\n\tudp: VoiceUDPSocket;\n\tconnectionOptions: ConnectionOptions;\n\tconnectionData: ConnectionData;\n\tpreparedPacket?: Buffer;\n}\n\n/**\n * The state that a Networking instance will be in when its connection has been dropped unexpectedly, and it\n * is attempting to resume an existing session.\n */\nexport interface NetworkingResumingState {\n\tcode: NetworkingStatusCode.Resuming;\n\tws: VoiceWebSocket;\n\tudp: VoiceUDPSocket;\n\tconnectionOptions: ConnectionOptions;\n\tconnectionData: ConnectionData;\n\tpreparedPacket?: Buffer;\n}\n\n/**\n * The state that a Networking instance will be in when it has been destroyed. It cannot be recovered from this\n * state.\n */\nexport interface NetworkingClosedState {\n\tcode: NetworkingStatusCode.Closed;\n}\n\n/**\n * The various states that a networking instance can be in.\n */\nexport type NetworkingState =\n\t| NetworkingOpeningWsState\n\t| NetworkingIdentifyingState\n\t| NetworkingUdpHandshakingState\n\t| NetworkingSelectingProtocolState\n\t| NetworkingReadyState\n\t| NetworkingResumingState\n\t| NetworkingClosedState;\n\n/**\n * Details required to connect to the Discord voice gateway. These details\n * are first received on the main bot gateway, in the form of VOICE_SERVER_UPDATE\n * and VOICE_STATE_UPDATE packets.\n */\ninterface ConnectionOptions {\n\tserverId: string;\n\tuserId: string;\n\tsessionId: string;\n\ttoken: string;\n\tendpoint: string;\n}\n\n/**\n * Information about the current connection, e.g. which encryption mode is to be used on\n * the connection, timing information for playback of streams.\n */\nexport interface ConnectionData {\n\tssrc: number;\n\tencryptionMode: string;\n\tsecretKey: Uint8Array;\n\tsequence: number;\n\ttimestamp: number;\n\tpacketsPlayed: number;\n\tnonce: number;\n\tnonceBuffer: Buffer;\n\tspeaking: boolean;\n}\n\n/**\n * An empty buffer that is reused in packet encryption by many different networking instances.\n */\nconst nonce = Buffer.alloc(24);\n\nexport interface NetworkingEvents {\n\tdebug: (message: string) => Awaited<void>;\n\terror: (error: Error) => Awaited<void>;\n\tstateChange: (oldState: NetworkingState, newState: NetworkingState) => Awaited<void>;\n\tclose: (code: number) => Awaited<void>;\n}\n\n/**\n * Stringifies a NetworkingState.\n *\n * @param state - The state to stringify\n */\nfunction stringifyState(state: NetworkingState) {\n\treturn JSON.stringify({\n\t\t...state,\n\t\tws: Reflect.has(state, 'ws'),\n\t\tudp: Reflect.has(state, 'udp'),\n\t});\n}\n\n/**\n * Chooses an encryption mode from a list of given options. Chooses the most preferred option.\n *\n * @param options - The available encryption options\n */\nfunction chooseEncryptionMode(options: string[]): string {\n\tconst option = options.find((option) => SUPPORTED_ENCRYPTION_MODES.includes(option));\n\tif (!option) {\n\t\tthrow new Error(`No compatible encryption modes. Available include: ${options.join(', ')}`);\n\t}\n\treturn option;\n}\n\n/**\n * Returns a random number that is in the range of n bits.\n *\n * @param n - The number of bits\n */\nfunction randomNBit(n: number) {\n\treturn Math.floor(Math.random() * 2 ** n);\n}\n\n/**\n * Manages the networking required to maintain a voice connection and dispatch audio packets\n */\nexport class Networking extends TypedEmitter<NetworkingEvents> {\n\tprivate _state: NetworkingState;\n\n\t/**\n\t * The debug logger function, if debugging is enabled.\n\t */\n\tprivate readonly debug: null | ((message: string) => void);\n\n\t/**\n\t * Creates a new Networking instance.\n\t */\n\tpublic constructor(options: ConnectionOptions, debug: boolean) {\n\t\tsuper();\n\n\t\tthis.onWsOpen = this.onWsOpen.bind(this);\n\t\tthis.onChildError = this.onChildError.bind(this);\n\t\tthis.onWsPacket = this.onWsPacket.bind(this);\n\t\tthis.onWsClose = this.onWsClose.bind(this);\n\t\tthis.onWsDebug = this.onWsDebug.bind(this);\n\t\tthis.onUdpDebug = this.onUdpDebug.bind(this);\n\t\tthis.onUdpClose = this.onUdpClose.bind(this);\n\n\t\tthis.debug = debug ? (message: string) => this.emit('debug', message) : null;\n\n\t\tthis._state = {\n\t\t\tcode: NetworkingStatusCode.OpeningWs,\n\t\t\tws: this.createWebSocket(options.endpoint),\n\t\t\tconnectionOptions: options,\n\t\t};\n\t}\n\n\t/**\n\t * Destroys the Networking instance, transitioning it into the Closed state.\n\t */\n\tpublic destroy() {\n\t\tthis.state = {\n\t\t\tcode: NetworkingStatusCode.Closed,\n\t\t};\n\t}\n\n\t/**\n\t * The current state of the networking instance.\n\t */\n\tpublic get state(): NetworkingState {\n\t\treturn this._state;\n\t}\n\n\t/**\n\t * Sets a new state for the networking instance, performing clean-up operations where necessary.\n\t */\n\tpublic set state(newState: NetworkingState) {\n\t\tconst oldWs = Reflect.get(this._state, 'ws') as VoiceWebSocket | undefined;\n\t\tconst newWs = Reflect.get(newState, 'ws') as VoiceWebSocket | undefined;\n\t\tif (oldWs && oldWs !== newWs) {\n\t\t\t// The old WebSocket is being freed - remove all handlers from it\n\t\t\toldWs.off('debug', this.onWsDebug);\n\t\t\toldWs.on('error', noop);\n\t\t\toldWs.off('error', this.onChildError);\n\t\t\toldWs.off('open', this.onWsOpen);\n\t\t\toldWs.off('packet', this.onWsPacket);\n\t\t\toldWs.off('close', this.onWsClose);\n\t\t\toldWs.destroy();\n\t\t}\n\n\t\tconst oldUdp = Reflect.get(this._state, 'udp') as VoiceUDPSocket | undefined;\n\t\tconst newUdp = Reflect.get(newState, 'udp') as VoiceUDPSocket | undefined;\n\n\t\tif (oldUdp && oldUdp !== newUdp) {\n\t\t\toldUdp.on('error', noop);\n\t\t\toldUdp.off('error', this.onChildError);\n\t\t\toldUdp.off('close', this.onUdpClose);\n\t\t\toldUdp.off('debug', this.onUdpDebug);\n\t\t\toldUdp.destroy();\n\t\t}\n\n\t\tconst oldState = this._state;\n\t\tthis._state = newState;\n\t\tthis.emit('stateChange', oldState, newState);\n\n\t\t/**\n\t\t * Debug event for Networking.\n\t\t *\n\t\t * @event Networking#debug\n\t\t * @type {string}\n\t\t */\n\t\tthis.debug?.(`state change:\\nfrom ${stringifyState(oldState)}\\nto ${stringifyState(newState)}`);\n\t}\n\n\t/**\n\t * Creates a new WebSocket to a Discord Voice gateway.\n\t *\n\t * @param endpoint - The endpoint to connect to\n\t * @param debug - Whether to enable debug logging\n\t */\n\tprivate createWebSocket(endpoint: string) {\n\t\tconst ws = new VoiceWebSocket(`wss://${endpoint}?v=4`, Boolean(this.debug));\n\n\t\tws.on('error', this.onChildError);\n\t\tws.once('open', this.onWsOpen);\n\t\tws.on('packet', this.onWsPacket);\n\t\tws.once('close', this.onWsClose);\n\t\tws.on('debug', this.onWsDebug);\n\n\t\treturn ws;\n\t}\n\n\t/**\n\t * Propagates errors from the children VoiceWebSocket and VoiceUDPSocket.\n\t *\n\t * @param error - The error that was emitted by a child\n\t */\n\tprivate onChildError(error: Error) {\n\t\tthis.emit('error', error);\n\t}\n\n\t/**\n\t * Called when the WebSocket opens. Depending on the state that the instance is in,\n\t * it will either identify with a new session, or it will attempt to resume an existing session.\n\t */\n\tprivate onWsOpen() {\n\t\tif (this.state.code === NetworkingStatusCode.OpeningWs) {\n\t\t\tconst packet = {\n\t\t\t\top: VoiceOpcodes.Identify,\n\t\t\t\td: {\n\t\t\t\t\tserver_id: this.state.connectionOptions.serverId,\n\t\t\t\t\tuser_id: this.state.connectionOptions.userId,\n\t\t\t\t\tsession_id: this.state.connectionOptions.sessionId,\n\t\t\t\t\ttoken: this.state.connectionOptions.token,\n\t\t\t\t},\n\t\t\t};\n\t\t\tthis.state.ws.sendPacket(packet);\n\t\t\tthis.state = {\n\t\t\t\t...this.state,\n\t\t\t\tcode: NetworkingStatusCode.Identifying,\n\t\t\t};\n\t\t} else if (this.state.code === NetworkingStatusCode.Resuming) {\n\t\t\tconst packet = {\n\t\t\t\top: VoiceOpcodes.Resume,\n\t\t\t\td: {\n\t\t\t\t\tserver_id: this.state.connectionOptions.serverId,\n\t\t\t\t\tsession_id: this.state.connectionOptions.sessionId,\n\t\t\t\t\ttoken: this.state.connectionOptions.token,\n\t\t\t\t},\n\t\t\t};\n\t\t\tthis.state.ws.sendPacket(packet);\n\t\t}\n\t}\n\n\t/**\n\t * Called when the WebSocket closes. Based on the reason for closing (given by the code parameter),\n\t * the instance will either attempt to resume, or enter the closed state and emit a 'close' event\n\t * with the close code, allowing the user to decide whether or not they would like to reconnect.\n\t *\n\t * @param code - The close code\n\t */\n\tprivate onWsClose({ code }: CloseEvent) {\n\t\tconst canResume = code === 4015 || code < 4000;\n\t\tif (canResume && this.state.code === NetworkingStatusCode.Ready) {\n\t\t\tthis.state = {\n\t\t\t\t...this.state,\n\t\t\t\tcode: NetworkingStatusCode.Resuming,\n\t\t\t\tws: this.createWebSocket(this.state.connectionOptions.endpoint),\n\t\t\t};\n\t\t} else if (this.state.code !== NetworkingStatusCode.Closed) {\n\t\t\tthis.destroy();\n\t\t\tthis.emit('close', code);\n\t\t}\n\t}\n\n\t/**\n\t * Called when the UDP socket has closed itself if it has stopped receiving replies from Discord.\n\t */\n\tprivate onUdpClose() {\n\t\tif (this.state.code === NetworkingStatusCode.Ready) {\n\t\t\tthis.state = {\n\t\t\t\t...this.state,\n\t\t\t\tcode: NetworkingStatusCode.Resuming,\n\t\t\t\tws: this.createWebSocket(this.state.connectionOptions.endpoint),\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Called when a packet is received on the connection's WebSocket.\n\t *\n\t * @param packet - The received packet\n\t */\n\tprivate onWsPacket(packet: any) {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\t\tif (packet.op === VoiceOpcodes.Hello && this.state.code !== NetworkingStatusCode.Closed) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n\t\t\tthis.state.ws.setHeartbeatInterval(packet.d.heartbeat_interval);\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\t\t} else if (packet.op === VoiceOpcodes.Ready && this.state.code === NetworkingStatusCode.Identifying) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n\t\t\tconst { ip, port, ssrc, modes } = packet.d;\n\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\t\t\tconst udp = new VoiceUDPSocket({ ip, port });\n\t\t\tudp.on('error', this.onChildError);\n\t\t\tudp.on('debug', this.onUdpDebug);\n\t\t\tudp.once('close', this.onUdpClose);\n\t\t\tudp\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n\t\t\t\t.performIPDiscovery(ssrc)\n\t\t\t\t.then((localConfig) => {\n\t\t\t\t\tif (this.state.code !== NetworkingStatusCode.UdpHandshaking) return;\n\t\t\t\t\tthis.state.ws.sendPacket({\n\t\t\t\t\t\top: VoiceOpcodes.SelectProtocol,\n\t\t\t\t\t\td: {\n\t\t\t\t\t\t\tprotocol: 'udp',\n\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\taddress: localConfig.ip,\n\t\t\t\t\t\t\t\tport: localConfig.port,\n\t\t\t\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n\t\t\t\t\t\t\t\tmode: chooseEncryptionMode(modes),\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t\tthis.state = {\n\t\t\t\t\t\t...this.state,\n\t\t\t\t\t\tcode: NetworkingStatusCode.SelectingProtocol,\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t\t.catch((error: Error) => this.emit('error', error));\n\n\t\t\tthis.state = {\n\t\t\t\t...this.state,\n\t\t\t\tcode: NetworkingStatusCode.UdpHandshaking,\n\t\t\t\tudp,\n\t\t\t\tconnectionData: {\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\t\t\t\t\tssrc,\n\t\t\t\t},\n\t\t\t};\n\t\t} else if (\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\t\t\tpacket.op === VoiceOpcodes.SessionDescription &&\n\t\t\tthis.state.code === NetworkingStatusCode.SelectingProtocol\n\t\t) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n\t\t\tconst { mode: encryptionMode, secret_key: secretKey } = packet.d;\n\t\t\tthis.state = {\n\t\t\t\t...this.state,\n\t\t\t\tcode: NetworkingStatusCode.Ready,\n\t\t\t\tconnectionData: {\n\t\t\t\t\t...this.state.connectionData,\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\t\t\t\t\tencryptionMode,\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n\t\t\t\t\tsecretKey: new Uint8Array(secretKey),\n\t\t\t\t\tsequence: randomNBit(16),\n\t\t\t\t\ttimestamp: randomNBit(32),\n\t\t\t\t\tnonce: 0,\n\t\t\t\t\tnonceBuffer: Buffer.alloc(24),\n\t\t\t\t\tspeaking: false,\n\t\t\t\t\tpacketsPlayed: 0,\n\t\t\t\t},\n\t\t\t};\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\t\t} else if (packet.op === VoiceOpcodes.Resumed && this.state.code === NetworkingStatusCode.Resuming) {\n\t\t\tthis.state = {\n\t\t\t\t...this.state,\n\t\t\t\tcode: NetworkingStatusCode.Ready,\n\t\t\t};\n\t\t\tthis.state.connectionData.speaking = false;\n\t\t}\n\t}\n\n\t/**\n\t * Propagates debug messages from the child WebSocket.\n\t *\n\t * @param message - The emitted debug message\n\t */\n\tprivate onWsDebug(message: string) {\n\t\tthis.debug?.(`[WS] ${message}`);\n\t}\n\n\t/**\n\t * Propagates debug messages from the child UDPSocket.\n\t *\n\t * @param message - The emitted debug message\n\t */\n\tprivate onUdpDebug(message: string) {\n\t\tthis.debug?.(`[UDP] ${message}`);\n\t}\n\n\t/**\n\t * Prepares an Opus packet for playback. This includes attaching metadata to it and encrypting it.\n\t * It will be stored within the instance, and can be played by dispatchAudio()\n\t *\n\t * @remarks\n\t * Calling this method while there is already a prepared audio packet that has not yet been dispatched\n\t * will overwrite the existing audio packet. This should be avoided.\n\t *\n\t * @param opusPacket - The Opus packet to encrypt\n\t *\n\t * @returns The audio packet that was prepared\n\t */\n\tpublic prepareAudioPacket(opusPacket: Buffer) {\n\t\tconst state = this.state;\n\t\tif (state.code !== NetworkingStatusCode.Ready) return;\n\t\tstate.preparedPacket = this.createAudioPacket(opusPacket, state.connectionData);\n\t\treturn state.preparedPacket;\n\t}\n\n\t/**\n\t * Dispatches the audio packet previously prepared by prepareAudioPacket(opusPacket). The audio packet\n\t * is consumed and cannot be dispatched again.\n\t */\n\tpublic dispatchAudio() {\n\t\tconst state = this.state;\n\t\tif (state.code !== NetworkingStatusCode.Ready) return false;\n\t\tif (typeof state.preparedPacket !== 'undefined') {\n\t\t\tthis.playAudioPacket(state.preparedPacket);\n\t\t\tstate.preparedPacket = undefined;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Plays an audio packet, updating timing metadata used for playback.\n\t *\n\t * @param audioPacket - The audio packet to play\n\t */\n\tprivate playAudioPacket(audioPacket: Buffer) {\n\t\tconst state = this.state;\n\t\tif (state.code !== NetworkingStatusCode.Ready) return;\n\t\tconst { connectionData } = state;\n\t\tconnectionData.packetsPlayed++;\n\t\tconnectionData.sequence++;\n\t\tconnectionData.timestamp += TIMESTAMP_INC;\n\t\tif (connectionData.sequence >= 2 ** 16) connectionData.sequence = 0;\n\t\tif (connectionData.timestamp >= 2 ** 32) connectionData.timestamp = 0;\n\t\tthis.setSpeaking(true);\n\t\tstate.udp.send(audioPacket);\n\t}\n\n\t/**\n\t * Sends a packet to the voice gateway indicating that the client has start/stopped sending\n\t * audio.\n\t *\n\t * @param speaking - Whether or not the client should be shown as speaking\n\t */\n\tpublic setSpeaking(speaking: boolean) {\n\t\tconst state = this.state;\n\t\tif (state.code !== NetworkingStatusCode.Ready) return;\n\t\tif (state.connectionData.speaking === speaking) return;\n\t\tstate.connectionData.speaking = speaking;\n\t\tstate.ws.sendPacket({\n\t\t\top: VoiceOpcodes.Speaking,\n\t\t\td: {\n\t\t\t\tspeaking: speaking ? 1 : 0,\n\t\t\t\tdelay: 0,\n\t\t\t\tssrc: state.connectionData.ssrc,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Creates a new audio packet from an Opus packet. This involves encrypting the packet,\n\t * then prepending a header that includes metadata.\n\t *\n\t * @param opusPacket - The Opus packet to prepare\n\t * @param connectionData - The current connection data of the instance\n\t */\n\tprivate createAudioPacket(opusPacket: Buffer, connectionData: ConnectionData) {\n\t\tconst packetBuffer = Buffer.alloc(12);\n\t\tpacketBuffer[0] = 0x80;\n\t\tpacketBuffer[1] = 0x78;\n\n\t\tconst { sequence, timestamp, ssrc } = connectionData;\n\n\t\tpacketBuffer.writeUIntBE(sequence, 2, 2);\n\t\tpacketBuffer.writeUIntBE(timestamp, 4, 4);\n\t\tpacketBuffer.writeUIntBE(ssrc, 8, 4);\n\n\t\tpacketBuffer.copy(nonce, 0, 0, 12);\n\t\treturn Buffer.concat([packetBuffer, ...this.encryptOpusPacket(opusPacket, connectionData)]);\n\t}\n\n\t/**\n\t * Encrypts an Opus packet using the format agreed upon by the instance and Discord.\n\t *\n\t * @param opusPacket - The Opus packet to encrypt\n\t * @param connectionData - The current connection data of the instance\n\t */\n\tprivate encryptOpusPacket(opusPacket: Buffer, connectionData: ConnectionData) {\n\t\tconst { secretKey, encryptionMode } = connectionData;\n\n\t\tif (encryptionMode === 'xsalsa20_poly1305_lite') {\n\t\t\tconnectionData.nonce++;\n\t\t\tif (connectionData.nonce > MAX_NONCE_SIZE) connectionData.nonce = 0;\n\t\t\tconnectionData.nonceBuffer.writeUInt32BE(connectionData.nonce, 0);\n\t\t\treturn [\n\t\t\t\tsecretbox.methods.close(opusPacket, connectionData.nonceBuffer, secretKey),\n\t\t\t\tconnectionData.nonceBuffer.slice(0, 4),\n\t\t\t];\n\t\t} else if (encryptionMode === 'xsalsa20_poly1305_suffix') {\n\t\t\tconst random = secretbox.methods.random(24, connectionData.nonceBuffer);\n\t\t\treturn [secretbox.methods.close(opusPacket, random, secretKey), random];\n\t\t}\n\t\treturn [secretbox.methods.close(opusPacket, nonce, secretKey)];\n\t}\n}\n","import { createSocket, Socket } from 'node:dgram';\nimport { isIPv4 } from 'node:net';\nimport { TypedEmitter } from 'tiny-typed-emitter';\nimport type { Awaited } from '../util/util';\n\n/**\n * Stores an IP address and port. Used to store socket details for the local client as well as\n * for Discord.\n */\nexport interface SocketConfig {\n\tip: string;\n\tport: number;\n}\n\ninterface KeepAlive {\n\tvalue: number;\n\ttimestamp: number;\n}\n\nexport interface VoiceUDPSocketEvents {\n\terror: (error: Error) => Awaited<void>;\n\tclose: () => Awaited<void>;\n\tdebug: (message: string) => Awaited<void>;\n\tmessage: (message: Buffer) => Awaited<void>;\n}\n\n/**\n * Parses the response from Discord to aid with local IP discovery.\n *\n * @param message - The received message\n */\nexport function parseLocalPacket(message: Buffer): SocketConfig {\n\tconst packet = Buffer.from(message);\n\n\tconst ip = packet.slice(8, packet.indexOf(0, 8)).toString('utf-8');\n\n\tif (!isIPv4(ip)) {\n\t\tthrow new Error('Malformed IP address');\n\t}\n\n\tconst port = packet.readUInt16BE(packet.length - 2);\n\n\treturn { ip, port };\n}\n\n/**\n * The interval in milliseconds at which keep alive datagrams are sent.\n */\nconst KEEP_ALIVE_INTERVAL = 5e3;\n\n/**\n * The maximum number of keep alive packets which can be missed.\n */\nconst KEEP_ALIVE_LIMIT = 12;\n\n/**\n * The maximum value of the keep alive counter.\n */\nconst MAX_COUNTER_VALUE = 2 ** 32 - 1;\n\n/**\n * Manages the UDP networking for a voice connection.\n */\nexport class VoiceUDPSocket extends TypedEmitter<VoiceUDPSocketEvents> {\n\t/**\n\t * The underlying network Socket for the VoiceUDPSocket.\n\t */\n\tprivate readonly socket: Socket;\n\n\t/**\n\t * The socket details for Discord (remote)\n\t */\n\tprivate readonly remote: SocketConfig;\n\n\t/**\n\t * A list of keep alives that are waiting to be acknowledged.\n\t */\n\tprivate readonly keepAlives: KeepAlive[];\n\n\t/**\n\t * The counter used in the keep alive mechanism.\n\t */\n\tprivate keepAliveCounter = 0;\n\n\t/**\n\t * The buffer used to write the keep alive counter into.\n\t */\n\tprivate readonly keepAliveBuffer: Buffer;\n\n\t/**\n\t * The Node.js interval for the keep-alive mechanism.\n\t */\n\tprivate readonly keepAliveInterval: NodeJS.Timeout;\n\n\t/**\n\t * The time taken to receive a response to keep alive messages.\n\t */\n\tpublic ping?: number;\n\n\t/**\n\t * The debug logger function, if debugging is enabled.\n\t */\n\tprivate readonly debug: null | ((message: string) => void);\n\n\t/**\n\t * Creates a new VoiceUDPSocket.\n\t *\n\t * @param remote - Details of the remote socket\n\t */\n\tpublic constructor(remote: SocketConfig, debug = false) {\n\t\tsuper();\n\t\tthis.socket = createSocket('udp4');\n\t\tthis.socket.on('error', (error: Error) => this.emit('error', error));\n\t\tthis.socket.on('message', (buffer: Buffer) => this.onMessage(buffer));\n\t\tthis.socket.on('close', () => this.emit('close'));\n\t\tthis.remote = remote;\n\t\tthis.keepAlives = [];\n\t\tthis.keepAliveBuffer = Buffer.alloc(8);\n\t\tthis.keepAliveInterval = setInterval(() => this.keepAlive(), KEEP_ALIVE_INTERVAL);\n\t\tsetImmediate(() => this.keepAlive());\n\n\t\tthis.debug = debug ? (message: string) => this.emit('debug', message) : null;\n\t}\n\n\t/**\n\t * Called when a message is received on the UDP socket.\n\t *\n\t * @param buffer The received buffer\n\t */\n\tprivate onMessage(buffer: Buffer): void {\n\t\t// Handle keep alive message\n\t\tif (buffer.length === 8) {\n\t\t\tconst counter = buffer.readUInt32LE(0);\n\t\t\tconst index = this.keepAlives.findIndex(({ value }) => value === counter);\n\t\t\tif (index === -1) return;\n\t\t\tthis.ping = Date.now() - this.keepAlives[index].timestamp;\n\t\t\t// Delete all keep alives up to and including the received one\n\t\t\tthis.keepAlives.splice(0, index);\n\t\t}\n\t\t// Propagate the message\n\t\tthis.emit('message', buffer);\n\t}\n\n\t/**\n\t * Called at a regular interval to check whether we are still able to send datagrams to Discord.\n\t */\n\tprivate keepAlive() {\n\t\tif (this.keepAlives.length >= KEEP_ALIVE_LIMIT) {\n\t\t\tthis.debug?.('UDP socket has not received enough responses from Discord - closing socket');\n\t\t\tthis.destroy();\n\t\t\treturn;\n\t\t}\n\n\t\tthis.keepAliveBuffer.writeUInt32LE(this.keepAliveCounter, 0);\n\t\tthis.send(this.keepAliveBuffer);\n\t\tthis.keepAlives.push({\n\t\t\tvalue: this.keepAliveCounter,\n\t\t\ttimestamp: Date.now(),\n\t\t});\n\t\tthis.keepAliveCounter++;\n\t\tif (this.keepAliveCounter > MAX_COUNTER_VALUE) {\n\t\t\tthis.keepAliveCounter = 0;\n\t\t}\n\t}\n\n\t/**\n\t * Sends a buffer to Discord.\n\t *\n\t * @param buffer - The buffer to send\n\t */\n\tpublic send(buffer: Buffer) {\n\t\treturn this.socket.send(buffer, this.remote.port, this.remote.ip);\n\t}\n\n\t/**\n\t * Closes the socket, the instance will not be able to be reused.\n\t */\n\tpublic destroy() {\n\t\ttry {\n\t\t\tthis.socket.close();\n\t\t} catch {}\n\t\tclearInterval(this.keepAliveInterval);\n\t}\n\n\t/**\n\t * Performs IP discovery to discover the local address and port to be used for the voice connection.\n\t *\n\t * @param ssrc - The SSRC received from Discord\n\t */\n\tpublic performIPDiscovery(ssrc: number): Promise<SocketConfig> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst listener = (message: Buffer) => {\n\t\t\t\ttry {\n\t\t\t\t\tif (message.readUInt16BE(0) !== 2) return;\n\t\t\t\t\tconst packet = parseLocalPacket(message);\n\t\t\t\t\tthis.socket.off('message', listener);\n\t\t\t\t\tresolve(packet);\n\t\t\t\t} catch {}\n\t\t\t};\n\n\t\t\tthis.socket.on('message', listener);\n\t\t\tthis.socket.once('close', () => reject(new Error('Cannot perform IP discovery - socket closed')));\n\n\t\t\tconst discoveryBuffer = Buffer.alloc(74);\n\n\t\t\tdiscoveryBuffer.writeUInt16BE(1, 0);\n\t\t\tdiscoveryBuffer.writeUInt16BE(70, 2);\n\t\t\tdiscoveryBuffer.writeUInt32BE(ssrc, 4);\n\t\t\tthis.send(discoveryBuffer);\n\t\t});\n\t}\n}\n","import { VoiceOpcodes } from 'discord-api-types/voice/v4';\nimport WebSocket, { MessageEvent } from 'ws';\nimport { TypedEmitter } from 'tiny-typed-emitter';\nimport type { Awaited } from '../util/util';\n\n/**\n * Debug event for VoiceWebSocket.\n *\n * @event VoiceWebSocket#debug\n * @type {string}\n */\n\nexport interface VoiceWebSocketEvents {\n\terror: (error: Error) => Awaited<void>;\n\topen: (event: WebSocket.Event) => Awaited<void>;\n\tclose: (event: WebSocket.CloseEvent) => Awaited<void>;\n\tdebug: (message: string) => Awaited<void>;\n\tpacket: (packet: any) => Awaited<void>;\n}\n\n/**\n * An extension of the WebSocket class to provide helper functionality when interacting\n * with the Discord Voice gateway.\n */\nexport class VoiceWebSocket extends TypedEmitter<VoiceWebSocketEvents> {\n\t/**\n\t * The current heartbeat interval, if any.\n\t */\n\tprivate heartbeatInterval?: NodeJS.Timeout;\n\n\t/**\n\t * The time (milliseconds since UNIX epoch) that the last heartbeat acknowledgement packet was received.\n\t * This is set to 0 if an acknowledgement packet hasn't been received yet.\n\t */\n\tprivate lastHeartbeatAck: number;\n\n\t/**\n\t * The time (milliseconds since UNIX epoch) that the last heartbeat was sent. This is set to 0 if a heartbeat\n\t * hasn't been sent yet.\n\t */\n\tprivate lastHeatbeatSend: number;\n\n\t/**\n\t * The number of consecutively missed heartbeats.\n\t */\n\tprivate missedHeartbeats = 0;\n\n\t/**\n\t * The last recorded ping.\n\t */\n\tpublic ping?: number;\n\n\t/**\n\t * The debug logger function, if debugging is enabled.\n\t */\n\tprivate readonly debug: null | ((message: string) => void);\n\n\t/**\n\t * The underlying WebSocket of this wrapper.\n\t */\n\tprivate readonly ws: WebSocket;\n\n\t/**\n\t * Creates a new VoiceWebSocket.\n\t *\n\t * @param address - The address to connect to\n\t */\n\tpublic constructor(address: string, debug: boolean) {\n\t\tsuper();\n\t\tthis.ws = new WebSocket(address);\n\t\tthis.ws.onmessage = (e) => this.onMessage(e);\n\t\tthis.ws.onopen = (e) => this.emit('open', e);\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n\t\tthis.ws.onerror = (e: Error | WebSocket.ErrorEvent) => this.emit('error', e instanceof Error ? e : e.error);\n\t\tthis.ws.onclose = (e) => this.emit('close', e);\n\n\t\tthis.lastHeartbeatAck = 0;\n\t\tthis.lastHeatbeatSend = 0;\n\n\t\tthis.debug = debug ? (message: string) => this.emit('debug', message) : null;\n\t}\n\n\t/**\n\t * Destroys the VoiceWebSocket. The heartbeat interval is cleared, and the connection is closed.\n\t */\n\tpublic destroy() {\n\t\ttry {\n\t\t\tthis.debug?.('destroyed');\n\t\t\tthis.setHeartbeatInterval(-1);\n\t\t\tthis.ws.close(1000);\n\t\t} catch (error) {\n\t\t\tconst e = error as Error;\n\t\t\tthis.emit('error', e);\n\t\t}\n\t}\n\n\t/**\n\t * Handles message events on the WebSocket. Attempts to JSON parse the messages and emit them\n\t * as packets.\n\t *\n\t * @param event - The message event\n\t */\n\tpublic onMessage(event: MessageEvent) {\n\t\tif (typeof event.data !== 'string') return;\n\n\t\tthis.debug?.(`<< ${event.data}`);\n\n\t\tlet packet: any;\n\t\ttry {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\t\t\tpacket = JSON.parse(event.data);\n\t\t} catch (error) {\n\t\t\tconst e = error as Error;\n\t\t\tthis.emit('error', e);\n\t\t\treturn;\n\t\t}\n\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\t\tif (packet.op === VoiceOpcodes.HeartbeatAck) {\n\t\t\tthis.lastHeartbeatAck = Date.now();\n\t\t\tthis.missedHeartbeats = 0;\n\t\t\tthis.ping = this.lastHeartbeatAck - this.lastHeatbeatSend;\n\t\t}\n\n\t\t/**\n\t\t * Packet event.\n\t\t *\n\t\t * @event VoiceWebSocket#packet\n\t\t * @type {any}\n\t\t */\n\t\tthis.emit('packet', packet);\n\t}\n\n\t/**\n\t * Sends a JSON-stringifiable packet over the WebSocket.\n\t *\n\t * @param packet - The packet to send\n\t */\n\tpublic sendPacket(packet: any) {\n\t\ttry {\n\t\t\tconst stringified = JSON.stringify(packet);\n\t\t\tthis.debug?.(`>> ${stringified}`);\n\t\t\treturn this.ws.send(stringified);\n\t\t} catch (error) {\n\t\t\tconst e = error as Error;\n\t\t\tthis.emit('error', e);\n\t\t}\n\t}\n\n\t/**\n\t * Sends a heartbeat over the WebSocket.\n\t */\n\tprivate sendHeartbeat() {\n\t\tthis.lastHeatbeatSend = Date.now();\n\t\tthis.missedHeartbeats++;\n\t\tconst nonce = this.lastHeatbeatSend;\n\t\treturn this.sendPacket({\n\t\t\top: VoiceOpcodes.Heartbeat,\n\t\t\td: nonce,\n\t\t});\n\t}\n\n\t/**\n\t * Sets/clears an interval to send heartbeats over the WebSocket.\n\t *\n\t * @param ms - The interval in milliseconds. If negative, the interval will be unset\n\t */\n\tpublic setHeartbeatInterval(ms: number) {\n\t\tif (typeof this.heartbeatInterval !== 'undefined') clearInterval(this.heartbeatInterval);\n\t\tif (ms > 0) {\n\t\t\tthis.heartbeatInterval = setInterval(() => {\n\t\t\t\tif (this.lastHeatbeatSend !== 0 && this.missedHeartbeats >= 3) {\n\t\t\t\t\t// Missed too many heartbeats - disconnect\n\t\t\t\t\tthis.ws.close();\n\t\t\t\t\tthis.setHeartbeatInterval(-1);\n\t\t\t\t}\n\t\t\t\tthis.sendHeartbeat();\n\t\t\t}, ms);\n\t\t}\n\t}\n}\n","interface Methods {\n\topen: (buffer: Buffer, nonce: Buffer, secretKey: Uint8Array) => Buffer | null;\n\tclose: (opusPacket: Buffer, nonce: Buffer, secretKey: Uint8Array) => Buffer;\n\trandom: (bytes: number, nonce: Buffer) => Buffer;\n}\n\nconst libs = {\n\tsodium: (sodium: any): Methods => ({\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n\t\topen: sodium.api.crypto_secretbox_open_easy,\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n\t\tclose: sodium.api.crypto_secretbox_easy,\n\t\trandom: (n: any, buffer?: Buffer) => {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n\t\t\tif (!buffer) buffer = Buffer.allocUnsafe(n);\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n\t\t\tsodium.api.randombytes_buf(buffer);\n\t\t\treturn buffer;\n\t\t},\n\t}),\n\t'libsodium-wrappers': (sodium: any): Methods => ({\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n\t\topen: sodium.crypto_secretbox_open_easy,\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n\t\tclose: sodium.crypto_secretbox_easy,\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n\t\trandom: (n: any) => sodium.randombytes_buf(n),\n\t}),\n\ttweetnacl: (tweetnacl: any): Methods => ({\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n\t\topen: tweetnacl.secretbox.open,\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n\t\tclose: tweetnacl.secretbox,\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call\n\t\trandom: (n: any) => tweetnacl.randomBytes(n),\n\t}),\n} as const;\n\nconst fallbackError = () => {\n\tthrow new Error(\n\t\t`Cannot play audio as no valid encryption package is installed.\n- Install sodium, libsodium-wrappers, or tweetnacl.\n- Use the generateDependencyReport() function for more information.\\n`,\n\t);\n};\n\nconst methods: Methods = {\n\topen: fallbackError,\n\tclose: fallbackError,\n\trandom: fallbackError,\n};\n\nvoid (async () => {\n\tfor (const libName of Object.keys(libs) as (keyof typeof libs)[]) {\n\t\ttry {\n\t\t\t// eslint-disable-next-line\n\t\t\tconst lib = require(libName);\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\t\t\tif (libName === 'libsodium-wrappers' && lib.ready) await lib.ready;\n\t\t\tObject.assign(methods, libs[libName](lib));\n\t\t\tbreak;\n\t\t} catch {}\n\t}\n})();\n\nexport { methods };\n","// eslint-disable-next-line @typescript-eslint/no-empty-function\nexport const noop = () => {};\n\nexport type Awaited<T> = T | Promise<T>;\n","/* eslint-disable @typescript-eslint/prefer-ts-expect-error */\nimport type { GatewayVoiceServerUpdateDispatchData, GatewayVoiceStateUpdateDispatchData } from 'discord-api-types/v9';\nimport type { CreateVoiceConnectionOptions } from '.';\nimport type { AudioPlayer } from './audio/AudioPlayer';\nimport type { PlayerSubscription } from './audio/PlayerSubscription';\nimport {\n\tgetVoiceConnection,\n\tcreateJoinVoiceChannelPayload,\n\ttrackVoiceConnection,\n\tJoinConfig,\n\tuntrackVoiceConnection,\n} from './DataStore';\nimport type { DiscordGatewayAdapterImplementerMethods } from './util/adapter';\nimport { Networking, NetworkingState, NetworkingStatusCode } from './networking/Networking';\nimport { Awaited, noop } from './util/util';\nimport { TypedEmitter } from 'tiny-typed-emitter';\nimport { VoiceReceiver } from './receive';\nimport type { VoiceWebSocket, VoiceUDPSocket } from './networking';\n\n/**\n * The various status codes a voice connection can hold at any one time.\n */\nexport enum VoiceConnectionStatus {\n\t/**\n\t * Sending a packet to the main Discord gateway to indicate we want to change our voice state.\n\t */\n\tSignalling = 'signalling',\n\n\t/**\n\t * The `VOICE_SERVER_UPDATE` and `VOICE_STATE_UPDATE` packets have been received, now attempting to establish a voice connection.\n\t */\n\tConnecting = 'connecting',\n\n\t/**\n\t * A voice connection has been established, and is ready to be used.\n\t */\n\tReady = 'ready',\n\n\t/**\n\t * The voice connection has either been severed or not established.\n\t */\n\tDisconnected = 'disconnected',\n\n\t/**\n\t * The voice connection has been destroyed and untracked, it cannot be reused.\n\t */\n\tDestroyed = 'destroyed',\n}\n\n/**\n * The state that a VoiceConnection will be in when it is waiting to receive a VOICE_SERVER_UPDATE and\n * VOICE_STATE_UPDATE packet from Discord, provided by the adapter.\n */\nexport interface VoiceConnectionSignallingState {\n\tstatus: VoiceConnectionStatus.Signalling;\n\tsubscription?: PlayerSubscription;\n\tadapter: DiscordGatewayAdapterImplementerMethods;\n}\n\n/**\n * The reasons a voice connection can be in the disconnected state.\n */\nexport enum VoiceConnectionDisconnectReason {\n\t/**\n\t * When the WebSocket connection has been closed.\n\t */\n\tWebSocketClose,\n\n\t/**\n\t * When the adapter was unable to send a message requested by the VoiceConnection.\n\t */\n\tAdapterUnavailable,\n\n\t/**\n\t * When a VOICE_SERVER_UPDATE packet is received with a null endpoint, causing the connection to be severed.\n\t */\n\tEndpointRemoved,\n\n\t/**\n\t * When a manual disconnect was requested.\n\t */\n\tManual,\n}\n\n/**\n * The state that a VoiceConnection will be in when it is not connected to a Discord voice server nor is\n * it attempting to connect. You can manually attempt to reconnect using VoiceConnection#reconnect.\n */\nexport interface VoiceConnectionDisconnectedBaseState {\n\tstatus: VoiceConnectionStatus.Disconnected;\n\tsubscription?: PlayerSubscription;\n\tadapter: DiscordGatewayAdapterImplementerMethods;\n}\n\n/**\n * The state that a VoiceConnection will be in when it is not connected to a Discord voice server nor is\n * it attempting to connect. You can manually attempt to reconnect using VoiceConnection#reconnect.\n */\nexport interface VoiceConnectionDisconnectedOtherState extends VoiceConnectionDisconnectedBaseState {\n\treason: Exclude<VoiceConnectionDisconnectReason, VoiceConnectionDisconnectReason.WebSocketClose>;\n}\n\n/**\n * The state that a VoiceConnection will be in when its WebSocket connection was closed.\n * You can manually attempt to reconnect using VoiceConnection#reconnect.\n */\nexport interface VoiceConnectionDisconnectedWebSocketState extends VoiceConnectionDisconnectedBaseState {\n\treason: VoiceConnectionDisconnectReason.WebSocketClose;\n\n\t/**\n\t * The close code of the WebSocket connection to the Discord voice server.\n\t */\n\tcloseCode: number;\n}\n\n/**\n * The states that a VoiceConnection can be in when it is not connected to a Discord voice server nor is\n * it attempting to connect. You can manually attempt to connect using VoiceConnection#reconnect.\n */\nexport type VoiceConnectionDisconnectedState =\n\t| VoiceConnectionDisconnectedOtherState\n\t| VoiceConnectionDisconnectedWebSocketState;\n\n/**\n * The state that a VoiceConnection will be in when it is establishing a connection to a Discord\n * voice server.\n */\nexport interface VoiceConnectionConnectingState {\n\tstatus: VoiceConnectionStatus.Connecting;\n\tnetworking: Networking;\n\tsubscription?: PlayerSubscription;\n\tadapter: DiscordGatewayAdapterImplementerMethods;\n}\n\n/**\n * The state that a VoiceConnection will be in when it has an active connection to a Discord\n * voice server.\n */\nexport interface VoiceConnectionReadyState {\n\tstatus: VoiceConnectionStatus.Ready;\n\tnetworking: Networking;\n\tsubscription?: PlayerSubscription;\n\tadapter: DiscordGatewayAdapterImplementerMethods;\n}\n\n/**\n * The state that a VoiceConnection will be in when it has been permanently been destroyed by the\n * user and untracked by the library. It cannot be reconnected, instead, a new VoiceConnection\n * needs to be established.\n */\nexport interface VoiceConnectionDestroyedState {\n\tstatus: VoiceConnectionStatus.Destroyed;\n}\n\n/**\n * The various states that a voice connection can be in.\n */\nexport type VoiceConnectionState =\n\t| VoiceConnectionSignallingState\n\t| VoiceConnectionDisconnectedState\n\t| VoiceConnectionConnectingState\n\t| VoiceConnectionReadyState\n\t| VoiceConnectionDestroyedState;\n\nexport type VoiceConnectionEvents = {\n\terror: (error: Error) => Awaited<void>;\n\tdebug: (message: string) => Awaited<void>;\n\tstateChange: (oldState: VoiceConnectionState, newState: VoiceConnectionState) => Awaited<void>;\n} & {\n\t[status in VoiceConnectionStatus]: (\n\t\toldState: VoiceConnectionState,\n\t\tnewState: VoiceConnectionState & { status: status },\n\t) => Awaited<void>;\n};\n\n/**\n * A connection to the voice server of a Guild, can be used to play audio in voice channels.\n */\nexport class VoiceConnection extends TypedEmitter<VoiceConnectionEvents> {\n\t/**\n\t * The number of consecutive rejoin attempts. Initially 0, and increments for each rejoin.\n\t * When a connection is successfully established, it resets to 0.\n\t */\n\tpublic rejoinAttempts: number;\n\n\t/**\n\t * The state of the voice connection.\n\t */\n\tprivate _state: VoiceConnectionState;\n\n\t/**\n\t * A configuration storing all the data needed to reconnect to a Guild's voice server.\n\t *\n\t * @internal\n\t */\n\tpublic readonly joinConfig: JoinConfig;\n\n\t/**\n\t * The two packets needed to successfully establish a voice connection. They are received\n\t * from the main Discord gateway after signalling to change the voice state.\n\t */\n\tprivate readonly packets: {\n\t\tserver: GatewayVoiceServerUpdateDispatchData | undefined;\n\t\tstate: GatewayVoiceStateUpdateDispatchData | undefined;\n\t};\n\n\t/**\n\t * The receiver of this voice connection. You should join the voice channel with `selfDeaf` set\n\t * to false for this feature to work properly.\n\t */\n\tpublic readonly receiver: VoiceReceiver;\n\n\t/**\n\t * The debug logger function, if debugging is enabled.\n\t */\n\tprivate readonly debug: null | ((message: string) => void);\n\n\t/**\n\t * Creates a new voice connection.\n\t *\n\t * @param joinConfig - The data required to establish the voice connection\n\t * @param options - The options used to create this voice connection\n\t */\n\tpublic constructor(joinConfig: JoinConfig, { debug, adapterCreator }: CreateVoiceConnectionOptions) {\n\t\tsuper();\n\n\t\tthis.debug = debug ? (message: string) => this.emit('debug', message) : null;\n\t\tthis.rejoinAttempts = 0;\n\n\t\tthis.receiver = new VoiceReceiver(this);\n\n\t\tthis.onNetworkingClose = this.onNetworkingClose.bind(this);\n\t\tthis.onNetworkingStateChange = this.onNetworkingStateChange.bind(this);\n\t\tthis.onNetworkingError = this.onNetworkingError.bind(this);\n\t\tthis.onNetworkingDebug = this.onNetworkingDebug.bind(this);\n\n\t\tconst adapter = adapterCreator({\n\t\t\tonVoiceServerUpdate: (data) => this.addServerPacket(data),\n\t\t\tonVoiceStateUpdate: (data) => this.addStatePacket(data),\n\t\t\tdestroy: () => this.destroy(false),\n\t\t});\n\n\t\tthis._state = { status: VoiceConnectionStatus.Signalling, adapter };\n\n\t\tthis.packets = {\n\t\t\tserver: undefined,\n\t\t\tstate: undefined,\n\t\t};\n\n\t\tthis.joinConfig = joinConfig;\n\t}\n\n\t/**\n\t * The current state of the voice connection.\n\t */\n\tpublic get state() {\n\t\treturn this._state;\n\t}\n\n\t/**\n\t * Updates the state of the voice connection, performing clean-up operations where necessary.\n\t */\n\tpublic set state(newState: VoiceConnectionState) {\n\t\tconst oldState = this._state;\n\t\tconst oldNetworking = Reflect.get(oldState, 'networking') as Networking | undefined;\n\t\tconst newNetworking = Reflect.get(newState, 'networking') as Networking | undefined;\n\n\t\tconst oldSubscription = Reflect.get(oldState, 'subscription') as PlayerSubscription | undefined;\n\t\tconst newSubscription = Reflect.get(newState, 'subscription') as PlayerSubscription | undefined;\n\n\t\tif (oldNetworking !== newNetworking) {\n\t\t\tif (oldNetworking) {\n\t\t\t\toldNetworking.on('error', noop);\n\t\t\t\toldNetworking.off('debug', this.onNetworkingDebug);\n\t\t\t\toldNetworking.off('error', this.onNetworkingError);\n\t\t\t\toldNetworking.off('close', this.onNetworkingClose);\n\t\t\t\toldNetworking.off('stateChange', this.onNetworkingStateChange);\n\t\t\t\toldNetworking.destroy();\n\t\t\t}\n\t\t\tif (newNetworking) this.updateReceiveBindings(newNetworking.state, oldNetworking?.state);\n\t\t}\n\n\t\tif (newState.status === VoiceConnectionStatus.Ready) {\n\t\t\tthis.rejoinAttempts = 0;\n\t\t} else if (newState.status === VoiceConnectionStatus.Destroyed) {\n\t\t\tfor (const stream of this.receiver.subscriptions.values()) {\n\t\t\t\tif (!stream.destroyed) stream.destroy();\n\t\t\t}\n\t\t}\n\n\t\t// If destroyed, the adapter can also be destroyed so it can be cleaned up by the user\n\t\tif (oldState.status !== VoiceConnectionStatus.Destroyed && newState.status === VoiceConnectionStatus.Destroyed) {\n\t\t\toldState.adapter.destroy();\n\t\t}\n\n\t\tthis._state = newState;\n\n\t\tif (oldSubscription && oldSubscription !== newSubscription) {\n\t\t\toldSubscription.unsubscribe();\n\t\t}\n\n\t\tthis.emit('stateChange', oldState, newState);\n\t\tif (oldState.status !== newState.status) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n\t\t\tthis.emit(newState.status, oldState, newState as any);\n\t\t}\n\t}\n\n\t/**\n\t * Registers a `VOICE_SERVER_UPDATE` packet to the voice connection. This will cause it to reconnect using the\n\t * new data provided in the packet.\n\t *\n\t * @param packet - The received `VOICE_SERVER_UPDATE` packet\n\t */\n\tprivate addServerPacket(packet: GatewayVoiceServerUpdateDispatchData) {\n\t\tthis.packets.server = packet;\n\t\tif (packet.endpoint) {\n\t\t\tthis.configureNetworking();\n\t\t} else if (this.state.status !== VoiceConnectionStatus.Destroyed) {\n\t\t\tthis.state = {\n\t\t\t\t...this.state,\n\t\t\t\tstatus: VoiceConnectionStatus.Disconnected,\n\t\t\t\treason: VoiceConnectionDisconnectReason.EndpointRemoved,\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Registers a `VOICE_STATE_UPDATE` packet to the voice connection. Most importantly, it stores the id of the\n\t * channel that the client is connected to.\n\t *\n\t * @param packet - The received `VOICE_STATE_UPDATE` packet\n\t */\n\tprivate addStatePacket(packet: GatewayVoiceStateUpdateDispatchData) {\n\t\tthis.packets.state = packet;\n\n\t\tif (typeof packet.self_deaf !== 'undefined') this.joinConfig.selfDeaf = packet.self_deaf;\n\t\tif (typeof packet.self_mute !== 'undefined') this.joinConfig.selfMute = packet.self_mute;\n\t\tif (packet.channel_id) this.joinConfig.channelId = packet.channel_id;\n\t\t/*\n\t\t\tthe channel_id being null doesn't necessarily mean it was intended for the client to leave the voice channel\n\t\t\tas it may have disconnected due to network failure. This will be gracefully handled once the voice websocket\n\t\t\tdies, and then it is up to the user to decide how they wish to handle this.\n\t\t*/\n\t}\n\n\t/**\n\t * Called when the networking state changes, and the new ws/udp packet/message handlers need to be rebound\n\t * to the new instances.\n\t * @param newState - The new networking state\n\t * @param oldState - The old networking state, if there is one\n\t */\n\tprivate updateReceiveBindings(newState: NetworkingState, oldState?: NetworkingState) {\n\t\tconst oldWs = Reflect.get(oldState ?? {}, 'ws') as VoiceWebSocket | undefined;\n\t\tconst newWs = Reflect.get(newState, 'ws') as VoiceWebSocket | undefined;\n\t\tconst oldUdp = Reflect.get(oldState ?? {}, 'udp') as VoiceUDPSocket | undefined;\n\t\tconst newUdp = Reflect.get(newState, 'udp') as VoiceUDPSocket | undefined;\n\n\t\tif (oldWs !== newWs) {\n\t\t\toldWs?.off('packet', this.receiver.onWsPacket);\n\t\t\tnewWs?.on('packet', this.receiver.onWsPacket);\n\t\t}\n\n\t\tif (oldUdp !== newUdp) {\n\t\t\toldUdp?.off('message', this.receiver.onUdpMessage);\n\t\t\tnewUdp?.on('message', this.receiver.onUdpMessage);\n\t\t}\n\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\t\tthis.receiver.connectionData = Reflect.get(newState, 'connectionData') ?? {};\n\t}\n\n\t/**\n\t * Attempts to configure a networking instance for this voice connection using the received packets.\n\t * Both packets are required, and any existing networking instance will be destroyed.\n\t *\n\t * @remarks\n\t * This is called when the voice server of the connection changes, e.g. if the bot is moved into a\n\t * different channel in the same guild but has a different voice server. In this instance, the connection\n\t * needs to be re-established to the new voice server.\n\t *\n\t * The connection will transition to the Connecting state when this is called.\n\t */\n\tpublic configureNetworking() {\n\t\tconst { server, state } = this.packets;\n\t\tif (!server || !state || this.state.status === VoiceConnectionStatus.Destroyed || !server.endpoint) return;\n\n\t\tconst networking = new Networking(\n\t\t\t{\n\t\t\t\tendpoint: server.endpoint,\n\t\t\t\tserverId: server.guild_id,\n\t\t\t\ttoken: server.token,\n\t\t\t\tsessionId: state.session_id,\n\t\t\t\tuserId: state.user_id,\n\t\t\t},\n\t\t\tBoolean(this.debug),\n\t\t);\n\n\t\tnetworking.once('close', this.onNetworkingClose);\n\t\tnetworking.on('stateChange', this.onNetworkingStateChange);\n\t\tnetworking.on('error', this.onNetworkingError);\n\t\tnetworking.on('debug', this.onNetworkingDebug);\n\n\t\tthis.state = {\n\t\t\t...this.state,\n\t\t\tstatus: VoiceConnectionStatus.Connecting,\n\t\t\tnetworking,\n\t\t};\n\t}\n\n\t/**\n\t * Called when the networking instance for this connection closes. If the close code is 4014 (do not reconnect),\n\t * the voice connection will transition to the Disconnected state which will store the close code. You can\n\t * decide whether or not to reconnect when this occurs by listening for the state change and calling reconnect().\n\t *\n\t * @remarks\n\t * If the close code was anything other than 4014, it is likely that the closing was not intended, and so the\n\t * VoiceConnection will signal to Discord that it would like to rejoin the channel. This automatically attempts\n\t * to re-establish the connection. This would be seen as a transition from the Ready state to the Signalling state.\n\t *\n\t * @param code - The close code\n\t */\n\tprivate onNetworkingClose(code: number) {\n\t\tif (this.state.status === VoiceConnectionStatus.Destroyed) return;\n\t\t// If networking closes, try to connect to the voice channel again.\n\t\tif (code === 4014) {\n\t\t\t// Disconnected - networking is already destroyed here\n\t\t\tthis.state = {\n\t\t\t\t...this.state,\n\t\t\t\tstatus: VoiceConnectionStatus.Disconnected,\n\t\t\t\treason: VoiceConnectionDisconnectReason.WebSocketClose,\n\t\t\t\tcloseCode: code,\n\t\t\t};\n\t\t} else {\n\t\t\tthis.state = {\n\t\t\t\t...this.state,\n\t\t\t\tstatus: VoiceConnectionStatus.Signalling,\n\t\t\t};\n\t\t\tthis.rejoinAttempts++;\n\t\t\tif (!this.state.adapter.sendPayload(createJoinVoiceChannelPayload(this.joinConfig))) {\n\t\t\t\tthis.state = {\n\t\t\t\t\t...this.state,\n\t\t\t\t\tstatus: VoiceConnectionStatus.Disconnected,\n\t\t\t\t\treason: VoiceConnectionDisconnectReason.AdapterUnavailable,\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Called when the state of the networking instance changes. This is used to derive the state of the voice connection.\n\t *\n\t * @param oldState - The previous state\n\t * @param newState - The new state\n\t */\n\tprivate onNetworkingStateChange(oldState: NetworkingState, newState: NetworkingState) {\n\t\tthis.updateReceiveBindings(newState, oldState);\n\t\tif (oldState.code === newState.code) return;\n\t\tif (this.state.status !== VoiceConnectionStatus.Connecting && this.state.status !== VoiceConnectionStatus.Ready)\n\t\t\treturn;\n\n\t\tif (newState.code === NetworkingStatusCode.Ready) {\n\t\t\tthis.state = {\n\t\t\t\t...this.state,\n\t\t\t\tstatus: VoiceConnectionStatus.Ready,\n\t\t\t};\n\t\t} else if (newState.code !== NetworkingStatusCode.Closed) {\n\t\t\tthis.state = {\n\t\t\t\t...this.state,\n\t\t\t\tstatus: VoiceConnectionStatus.Connecting,\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Propagates errors from the underlying network instance.\n\t *\n\t * @param error - The error to propagate\n\t */\n\tprivate onNetworkingError(error: Error) {\n\t\tthis.emit('error', error);\n\t}\n\n\t/**\n\t * Propagates debug messages from the underlying network instance.\n\t *\n\t * @param message - The debug message to propagate\n\t */\n\tprivate onNetworkingDebug(message: string) {\n\t\tthis.debug?.(`[NW] ${message}`);\n\t}\n\n\t/**\n\t * Prepares an audio packet for dispatch.\n\t *\n\t * @param buffer - The Opus packet to prepare\n\t */\n\tpublic prepareAudioPacket(buffer: Buffer) {\n\t\tconst state = this.state;\n\t\tif (state.status !== VoiceConnectionStatus.Ready) return;\n\t\treturn state.networking.prepareAudioPacket(buffer);\n\t}\n\n\t/**\n\t * Dispatches the previously prepared audio packet (if any)\n\t */\n\tpublic dispatchAudio() {\n\t\tconst state = this.state;\n\t\tif (state.status !== VoiceConnectionStatus.Ready) return;\n\t\treturn state.networking.dispatchAudio();\n\t}\n\n\t/**\n\t * Prepares an audio packet and dispatches it immediately.\n\t *\n\t * @param buffer - The Opus packet to play\n\t */\n\tpublic playOpusPacket(buffer: Buffer) {\n\t\tconst state = this.state;\n\t\tif (state.status !== VoiceConnectionStatus.Ready) return;\n\t\tstate.networking.prepareAudioPacket(buffer);\n\t\treturn state.networking.dispatchAudio();\n\t}\n\n\t/**\n\t * Destroys the VoiceConnection, preventing it from connecting to voice again.\n\t * This method should be called when you no longer require the VoiceConnection to\n\t * prevent memory leaks.\n\t *\n\t * @param adapterAvailable - Whether the adapter can be used\n\t */\n\tpublic destroy(adapterAvailable = true) {\n\t\tif (this.state.status === VoiceConnectionStatus.Destroyed) {\n\t\t\tthrow new Error('Cannot destroy VoiceConnection - it has already been destroyed');\n\t\t}\n\t\tif (getVoiceConnection(this.joinConfig.guildId) === this) {\n\t\t\tuntrackVoiceConnection(this);\n\t\t}\n\t\tif (adapterAvailable) {\n\t\t\tthis.state.adapter.sendPayload(createJoinVoiceChannelPayload({ ...this.joinConfig, channelId: null }));\n\t\t}\n\t\tthis.state = {\n\t\t\tstatus: VoiceConnectionStatus.Destroyed,\n\t\t};\n\t}\n\n\t/**\n\t * Disconnects the VoiceConnection, allowing the possibility of rejoining later on.\n\t *\n\t * @returns `true` if the connection was successfully disconnected\n\t */\n\tpublic disconnect() {\n\t\tif (\n\t\t\tthis.state.status === VoiceConnectionStatus.Destroyed ||\n\t\t\tthis.state.status === VoiceConnectionStatus.Signalling\n\t\t) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.joinConfig.channelId = null;\n\t\tif (!this.state.adapter.sendPayload(createJoinVoiceChannelPayload(this.joinConfig))) {\n\t\t\tthis.state = {\n\t\t\t\tadapter: this.state.adapter,\n\t\t\t\tsubscription: this.state.subscription,\n\t\t\t\tstatus: VoiceConnectionStatus.Disconnected,\n\t\t\t\treason: VoiceConnectionDisconnectReason.AdapterUnavailable,\n\t\t\t};\n\t\t\treturn false;\n\t\t}\n\t\tthis.state = {\n\t\t\tadapter: this.state.adapter,\n\t\t\treason: VoiceConnectionDisconnectReason.Manual,\n\t\t\tstatus: VoiceConnectionStatus.Disconnected,\n\t\t};\n\t\treturn true;\n\t}\n\n\t/**\n\t * Attempts to rejoin (better explanation soon:tm:)\n\t *\n\t * @remarks\n\t * Calling this method successfully will automatically increment the `rejoinAttempts` counter,\n\t * which you can use to inform whether or not you'd like to keep attempting to reconnect your\n\t * voice connection.\n\t *\n\t * A state transition from Disconnected to Signalling will be observed when this is called.\n\t */\n\tpublic rejoin(joinConfig?: Omit<JoinConfig, 'guildId' | 'group'>) {\n\t\tif (this.state.status === VoiceConnectionStatus.Destroyed) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst notReady = this.state.status !== VoiceConnectionStatus.Ready;\n\n\t\tif (notReady) this.rejoinAttempts++;\n\t\tObject.assign(this.joinConfig, joinConfig);\n\t\tif (this.state.adapter.sendPayload(createJoinVoiceChannelPayload(this.joinConfig))) {\n\t\t\tif (notReady) {\n\t\t\t\tthis.state = {\n\t\t\t\t\t...this.state,\n\t\t\t\t\tstatus: VoiceConnectionStatus.Signalling,\n\t\t\t\t};\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tthis.state = {\n\t\t\tadapter: this.state.adapter,\n\t\t\tsubscription: this.state.subscription,\n\t\t\tstatus: VoiceConnectionStatus.Disconnected,\n\t\t\treason: VoiceConnectionDisconnectReason.AdapterUnavailable,\n\t\t};\n\t\treturn false;\n\t}\n\n\t/**\n\t * Updates the speaking status of the voice connection. This is used when audio players are done playing audio,\n\t * and need to signal that the connection is no longer playing audio.\n\t *\n\t * @param enabled - Whether or not to show as speaking\n\t */\n\tpublic setSpeaking(enabled: boolean) {\n\t\tif (this.state.status !== VoiceConnectionStatus.Ready) return false;\n\t\treturn this.state.networking.setSpeaking(enabled);\n\t}\n\n\t/**\n\t * Subscribes to an audio player, allowing the player to play audio on this voice connection.\n\t *\n\t * @param player - The audio player to subscribe to\n\t *\n\t * @returns The created subscription\n\t */\n\tpublic subscribe(player: AudioPlayer) {\n\t\tif (this.state.status === VoiceConnectionStatus.Destroyed) return;\n\n\t\t// eslint-disable-next-line @typescript-eslint/dot-notation\n\t\tconst subscription = player['subscribe'](this);\n\n\t\tthis.state = {\n\t\t\t...this.state,\n\t\t\tsubscription,\n\t\t};\n\n\t\treturn subscription;\n\t}\n\n\t/**\n\t * The latest ping (in milliseconds) for the WebSocket connection and audio playback for this voice\n\t * connection, if this data is available.\n\t *\n\t * @remarks\n\t * For this data to be available, the VoiceConnection must be in the Ready state, and its underlying\n\t * WebSocket connection and UDP socket must have had at least one ping-pong exchange.\n\t */\n\tpublic get ping() {\n\t\tif (\n\t\t\tthis.state.status === VoiceConnectionStatus.Ready &&\n\t\t\tthis.state.networking.state.code === NetworkingStatusCode.Ready\n\t\t) {\n\t\t\treturn {\n\t\t\t\tws: this.state.networking.state.ws.ping,\n\t\t\t\tudp: this.state.networking.state.udp.ping,\n\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\tws: undefined,\n\t\t\tudp: undefined,\n\t\t};\n\t}\n\n\t/**\n\t * Called when a subscription of this voice connection to an audio player is removed.\n\t *\n\t * @param subscription - The removed subscription\n\t */\n\t// @ts-ignore\n\tprivate onSubscriptionRemoved(subscription: PlayerSubscription) {\n\t\tif (this.state.status !== VoiceConnectionStatus.Destroyed && this.state.subscription === subscription) {\n\t\t\tthis.state = {\n\t\t\t\t...this.state,\n\t\t\t\tsubscription: undefined,\n\t\t\t};\n\t\t}\n\t}\n}\n\n/**\n * Creates a new voice connection.\n *\n * @param joinConfig - The data required to establish the voice connection\n * @param options - The options to use when joining the voice channel\n */\nexport function createVoiceConnection(joinConfig: JoinConfig, options: CreateVoiceConnectionOptions) {\n\tconst payload = createJoinVoiceChannelPayload(joinConfig);\n\tconst existing = getVoiceConnection(joinConfig.guildId);\n\tif (existing && existing.state.status !== VoiceConnectionStatus.Destroyed) {\n\t\tif (existing.state.status === VoiceConnectionStatus.Disconnected) {\n\t\t\texisting.rejoin({\n\t\t\t\tchannelId: joinConfig.channelId,\n\t\t\t\tselfDeaf: joinConfig.selfDeaf,\n\t\t\t\tselfMute: joinConfig.selfMute,\n\t\t\t});\n\t\t} else if (!existing.state.adapter.sendPayload(payload)) {\n\t\t\texisting.state = {\n\t\t\t\t...existing.state,\n\t\t\t\tstatus: VoiceConnectionStatus.Disconnected,\n\t\t\t\treason: VoiceConnectionDisconnectReason.AdapterUnavailable,\n\t\t\t};\n\t\t}\n\t\treturn existing;\n\t}\n\n\tconst voiceConnection = new VoiceConnection(joinConfig, options);\n\ttrackVoiceConnection(voiceConnection);\n\tif (voiceConnection.state.status !== VoiceConnectionStatus.Destroyed) {\n\t\tif (!voiceConnection.state.adapter.sendPayload(payload)) {\n\t\t\tvoiceConnection.state = {\n\t\t\t\t...voiceConnection.state,\n\t\t\t\tstatus: VoiceConnectionStatus.Disconnected,\n\t\t\t\treason: VoiceConnectionDisconnectReason.AdapterUnavailable,\n\t\t\t};\n\t\t}\n\t}\n\treturn voiceConnection;\n}\n","import { VoiceOpcodes } from 'discord-api-types/voice/v4';\nimport type { ConnectionData } from '../networking/Networking';\nimport { methods } from '../util/Secretbox';\nimport type { VoiceConnection } from '../VoiceConnection';\nimport {\n\tAudioReceiveStream,\n\tAudioReceiveStreamOptions,\n\tcreateDefaultAudioReceiveStreamOptions,\n} from './AudioReceiveStream';\nimport { SpeakingMap } from './SpeakingMap';\nimport { SSRCMap } from './SSRCMap';\n\n/**\n * Attaches to a VoiceConnection, allowing you to receive audio packets from other\n * users that are speaking.\n *\n * @beta\n */\nexport class VoiceReceiver {\n\t/**\n\t * The attached connection of this receiver.\n\t */\n\tpublic readonly voiceConnection;\n\n\t/**\n\t * Maps SSRCs to Discord user ids.\n\t */\n\tpublic readonly ssrcMap: SSRCMap;\n\n\t/**\n\t * The current audio subscriptions of this receiver.\n\t */\n\tpublic readonly subscriptions: Map<string, AudioReceiveStream>;\n\n\t/**\n\t * The connection data of the receiver.\n\t *\n\t * @internal\n\t */\n\tpublic connectionData: Partial<ConnectionData>;\n\n\t/**\n\t * The speaking map of the receiver.\n\t */\n\tpublic readonly speaking: SpeakingMap;\n\n\tpublic constructor(voiceConnection: VoiceConnection) {\n\t\tthis.voiceConnection = voiceConnection;\n\t\tthis.ssrcMap = new SSRCMap();\n\t\tthis.speaking = new SpeakingMap();\n\t\tthis.subscriptions = new Map();\n\t\tthis.connectionData = {};\n\n\t\tthis.onWsPacket = this.onWsPacket.bind(this);\n\t\tthis.onUdpMessage = this.onUdpMessage.bind(this);\n\t}\n\n\t/**\n\t * Called when a packet is received on the attached connection's WebSocket.\n\t *\n\t * @param packet The received packet\n\t *\n\t * @internal\n\t */\n\tpublic onWsPacket(packet: any) {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\t\tif (packet.op === VoiceOpcodes.ClientDisconnect && typeof packet.d?.user_id === 'string') {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-member-access\n\t\t\tthis.ssrcMap.delete(packet.d.user_id);\n\t\t} else if (\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\t\t\tpacket.op === VoiceOpcodes.Speaking &&\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\t\t\ttypeof packet.d?.user_id === 'string' &&\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\t\t\ttypeof packet.d?.ssrc === 'number'\n\t\t) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n\t\t\tthis.ssrcMap.update({ userId: packet.d.user_id, audioSSRC: packet.d.ssrc });\n\t\t} else if (\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\t\t\tpacket.op === VoiceOpcodes.ClientConnect &&\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\t\t\ttypeof packet.d?.user_id === 'string' &&\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\t\t\ttypeof packet.d?.audio_ssrc === 'number'\n\t\t) {\n\t\t\tthis.ssrcMap.update({\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n\t\t\t\tuserId: packet.d.user_id,\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n\t\t\t\taudioSSRC: packet.d.audio_ssrc,\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n\t\t\t\tvideoSSRC: packet.d.video_ssrc === 0 ? undefined : packet.d.video_ssrc,\n\t\t\t});\n\t\t}\n\t}\n\n\tprivate decrypt(buffer: Buffer, mode: string, nonce: Buffer, secretKey: Uint8Array) {\n\t\t// Choose correct nonce depending on encryption\n\t\tlet end;\n\t\tif (mode === 'xsalsa20_poly1305_lite') {\n\t\t\tbuffer.copy(nonce, 0, buffer.length - 4);\n\t\t\tend = buffer.length - 4;\n\t\t} else if (mode === 'xsalsa20_poly1305_suffix') {\n\t\t\tbuffer.copy(nonce, 0, buffer.length - 24);\n\t\t\tend = buffer.length - 24;\n\t\t} else {\n\t\t\tbuffer.copy(nonce, 0, 0, 12);\n\t\t}\n\n\t\t// Open packet\n\t\tconst decrypted = methods.open(buffer.slice(12, end), nonce, secretKey);\n\t\tif (!decrypted) return;\n\t\treturn Buffer.from(decrypted);\n\t}\n\n\t/**\n\t * Parses an audio packet, decrypting it to yield an Opus packet.\n\t *\n\t * @param buffer The buffer to parse\n\t * @param mode The encryption mode\n\t * @param nonce The nonce buffer used by the connection for encryption\n\t * @param secretKey The secret key used by the connection for encryption\n\t *\n\t * @returns The parsed Opus packet\n\t */\n\tprivate parsePacket(buffer: Buffer, mode: string, nonce: Buffer, secretKey: Uint8Array) {\n\t\tlet packet = this.decrypt(buffer, mode, nonce, secretKey);\n\t\tif (!packet) return;\n\n\t\t// Strip RTP Header Extensions (one-byte only)\n\t\tif (packet[0] === 0xbe && packet[1] === 0xde && packet.length > 4) {\n\t\t\tconst headerExtensionLength = packet.readUInt16BE(2);\n\t\t\tlet offset = 4;\n\t\t\tfor (let i = 0; i < headerExtensionLength; i++) {\n\t\t\t\tconst byte = packet[offset];\n\t\t\t\toffset++;\n\t\t\t\tif (byte === 0) continue;\n\t\t\t\toffset += 1 + (byte >> 4);\n\t\t\t}\n\t\t\t// Skip over undocumented Discord byte (if present)\n\t\t\tconst byte = packet.readUInt8(offset);\n\t\t\tif (byte === 0x00 || byte === 0x02) offset++;\n\n\t\t\tpacket = packet.slice(offset);\n\t\t}\n\n\t\treturn packet;\n\t}\n\n\t/**\n\t * Called when the UDP socket of the attached connection receives a message.\n\t *\n\t * @param msg The received message\n\t *\n\t * @internal\n\t */\n\tpublic onUdpMessage(msg: Buffer) {\n\t\tif (msg.length <= 8) return;\n\t\tconst ssrc = msg.readUInt32BE(8);\n\n\t\tconst userData = this.ssrcMap.get(ssrc);\n\t\tif (!userData) return;\n\n\t\tthis.speaking.onPacket(userData.userId);\n\n\t\tconst stream = this.subscriptions.get(userData.userId);\n\t\tif (!stream) return;\n\n\t\tif (this.connectionData.encryptionMode && this.connectionData.nonceBuffer && this.connectionData.secretKey) {\n\t\t\tconst packet = this.parsePacket(\n\t\t\t\tmsg,\n\t\t\t\tthis.connectionData.encryptionMode,\n\t\t\t\tthis.connectionData.nonceBuffer,\n\t\t\t\tthis.connectionData.secretKey,\n\t\t\t);\n\t\t\tif (packet) {\n\t\t\t\tstream.push(packet);\n\t\t\t} else {\n\t\t\t\tstream.destroy(new Error('Failed to parse packet'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates a subscription for the given user id.\n\t *\n\t * @param target The id of the user to subscribe to\n\t *\n\t * @returns A readable stream of Opus packets received from the target\n\t */\n\tpublic subscribe(userId: string, options?: Partial<AudioReceiveStreamOptions>) {\n\t\tconst existing = this.subscriptions.get(userId);\n\t\tif (existing) return existing;\n\n\t\tconst stream = new AudioReceiveStream({\n\t\t\t...createDefaultAudioReceiveStreamOptions(),\n\t\t\t...options,\n\t\t});\n\n\t\tstream.once('close', () => this.subscriptions.delete(userId));\n\t\tthis.subscriptions.set(userId, stream);\n\t\treturn stream;\n\t}\n}\n","import { Readable, ReadableOptions } from 'node:stream';\nimport { SILENCE_FRAME } from '../audio/AudioPlayer';\n\n/**\n * The different behaviors an audio receive stream can have for deciding when to end.\n */\nexport enum EndBehaviorType {\n\t/**\n\t * The stream will only end when manually destroyed.\n\t */\n\tManual,\n\n\t/**\n\t * The stream will end after a given time period of silence/no audio packets.\n\t */\n\tAfterSilence,\n\n\t/**\n\t * The stream will end after a given time period of no audio packets.\n\t */\n\tAfterInactivity,\n}\n\nexport type EndBehavior =\n\t| {\n\t\t\tbehavior: EndBehaviorType.Manual;\n\t  }\n\t| {\n\t\t\tbehavior: EndBehaviorType.AfterSilence | EndBehaviorType.AfterInactivity;\n\t\t\tduration: number;\n\t  };\n\nexport interface AudioReceiveStreamOptions extends ReadableOptions {\n\tend: EndBehavior;\n}\n\nexport function createDefaultAudioReceiveStreamOptions(): AudioReceiveStreamOptions {\n\treturn {\n\t\tend: {\n\t\t\tbehavior: EndBehaviorType.Manual,\n\t\t},\n\t};\n}\n\n/**\n * A readable stream of Opus packets received from a specific entity\n * in a Discord voice connection.\n */\nexport class AudioReceiveStream extends Readable {\n\t/**\n\t * The end behavior of the receive stream.\n\t */\n\tpublic readonly end: EndBehavior;\n\n\tprivate endTimeout?: NodeJS.Timeout;\n\n\tpublic constructor({ end, ...options }: AudioReceiveStreamOptions) {\n\t\tsuper({\n\t\t\t...options,\n\t\t\tobjectMode: true,\n\t\t});\n\n\t\tthis.end = end;\n\t}\n\n\tpublic override push(buffer: Buffer | null) {\n\t\tif (buffer) {\n\t\t\tif (\n\t\t\t\tthis.end.behavior === EndBehaviorType.AfterInactivity ||\n\t\t\t\t(this.end.behavior === EndBehaviorType.AfterSilence &&\n\t\t\t\t\t(buffer.compare(SILENCE_FRAME) !== 0 || typeof this.endTimeout === 'undefined'))\n\t\t\t) {\n\t\t\t\tthis.renewEndTimeout(this.end);\n\t\t\t}\n\t\t}\n\n\t\treturn super.push(buffer);\n\t}\n\n\tprivate renewEndTimeout(end: EndBehavior & { duration: number }) {\n\t\tif (this.endTimeout) {\n\t\t\tclearTimeout(this.endTimeout);\n\t\t}\n\t\tthis.endTimeout = setTimeout(() => this.push(null), end.duration);\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/no-empty-function\n\tpublic override _read() {}\n}\n","import type { AudioResource } from './AudioResource';\n\n/**\n * An error emitted by an AudioPlayer. Contains an attached resource to aid with\n * debugging and identifying where the error came from.\n */\nexport class AudioPlayerError extends Error {\n\t/**\n\t * The resource associated with the audio player at the time the error was thrown.\n\t */\n\tpublic readonly resource: AudioResource;\n\tpublic constructor(error: Error, resource: AudioResource) {\n\t\tsuper(error.message);\n\t\tthis.resource = resource;\n\t\tthis.name = error.name;\n\t\tthis.stack = error.stack;\n\t}\n}\n","/* eslint-disable @typescript-eslint/dot-notation */\nimport type { VoiceConnection } from '../VoiceConnection';\nimport type { AudioPlayer } from './AudioPlayer';\n\n/**\n * Represents a subscription of a voice connection to an audio player, allowing\n * the audio player to play audio on the voice connection.\n */\nexport class PlayerSubscription {\n\t/**\n\t * The voice connection of this subscription.\n\t */\n\tpublic readonly connection: VoiceConnection;\n\n\t/**\n\t * The audio player of this subscription.\n\t */\n\tpublic readonly player: AudioPlayer;\n\n\tpublic constructor(connection: VoiceConnection, player: AudioPlayer) {\n\t\tthis.connection = connection;\n\t\tthis.player = player;\n\t}\n\n\t/**\n\t * Unsubscribes the connection from the audio player, meaning that the\n\t * audio player cannot stream audio to it until a new subscription is made.\n\t */\n\tpublic unsubscribe() {\n\t\tthis.connection['onSubscriptionRemoved'](this);\n\t\tthis.player['unsubscribe'](this);\n\t}\n}\n","/* eslint-disable @typescript-eslint/prefer-ts-expect-error */\nimport { addAudioPlayer, deleteAudioPlayer } from '../DataStore';\nimport { Awaited, noop } from '../util/util';\nimport { VoiceConnection, VoiceConnectionStatus } from '../VoiceConnection';\nimport { AudioPlayerError } from './AudioPlayerError';\nimport type { AudioResource } from './AudioResource';\nimport { PlayerSubscription } from './PlayerSubscription';\nimport { TypedEmitter } from 'tiny-typed-emitter';\n\n// The Opus \"silent\" frame\nexport const SILENCE_FRAME = Buffer.from([0xf8, 0xff, 0xfe]);\n\n/**\n * Describes the behavior of the player when an audio packet is played but there are no available\n * voice connections to play to.\n */\nexport enum NoSubscriberBehavior {\n\t/**\n\t * Pauses playing the stream until a voice connection becomes available.\n\t */\n\tPause = 'pause',\n\n\t/**\n\t * Continues to play through the resource regardless.\n\t */\n\tPlay = 'play',\n\n\t/**\n\t * The player stops and enters the Idle state.\n\t */\n\tStop = 'stop',\n}\n\nexport enum AudioPlayerStatus {\n\t/**\n\t * When there is currently no resource for the player to be playing.\n\t */\n\tIdle = 'idle',\n\n\t/**\n\t * When the player is waiting for an audio resource to become readable before transitioning to Playing.\n\t */\n\tBuffering = 'buffering',\n\n\t/**\n\t * When the player has been manually paused.\n\t */\n\tPaused = 'paused',\n\n\t/**\n\t * When the player is actively playing an audio resource.\n\t */\n\tPlaying = 'playing',\n\n\t/**\n\t * When the player has paused itself. Only possible with the \"pause\" no subscriber behavior.\n\t */\n\tAutoPaused = 'autopaused',\n}\n\n/**\n * Options that can be passed when creating an audio player, used to specify its behavior.\n */\nexport interface CreateAudioPlayerOptions {\n\tdebug?: boolean;\n\tbehaviors?: {\n\t\tnoSubscriber?: NoSubscriberBehavior;\n\t\tmaxMissedFrames?: number;\n\t};\n}\n\n/**\n * The state that an AudioPlayer is in when it has no resource to play. This is the starting state.\n */\nexport interface AudioPlayerIdleState {\n\tstatus: AudioPlayerStatus.Idle;\n}\n\n/**\n * The state that an AudioPlayer is in when it is waiting for a resource to become readable. Once this\n * happens, the AudioPlayer will enter the Playing state. If the resource ends/errors before this, then\n * it will re-enter the Idle state.\n */\nexport interface AudioPlayerBufferingState {\n\tstatus: AudioPlayerStatus.Buffering;\n\t/**\n\t * The resource that the AudioPlayer is waiting for\n\t */\n\tresource: AudioResource;\n\tonReadableCallback: () => void;\n\tonFailureCallback: () => void;\n\tonStreamError: (error: Error) => void;\n}\n\n/**\n * The state that an AudioPlayer is in when it is actively playing an AudioResource. When playback ends,\n * it will enter the Idle state.\n */\nexport interface AudioPlayerPlayingState {\n\tstatus: AudioPlayerStatus.Playing;\n\t/**\n\t * The number of consecutive times that the audio resource has been unable to provide an Opus frame.\n\t */\n\tmissedFrames: number;\n\n\t/**\n\t * The playback duration in milliseconds of the current audio resource. This includes filler silence packets\n\t * that have been played when the resource was buffering.\n\t */\n\tplaybackDuration: number;\n\n\t/**\n\t * The resource that is being played.\n\t */\n\tresource: AudioResource;\n\n\tonStreamError: (error: Error) => void;\n}\n\n/**\n * The state that an AudioPlayer is in when it has either been explicitly paused by the user, or done\n * automatically by the AudioPlayer itself if there are no available subscribers.\n */\nexport interface AudioPlayerPausedState {\n\tstatus: AudioPlayerStatus.Paused | AudioPlayerStatus.AutoPaused;\n\t/**\n\t * How many silence packets still need to be played to avoid audio interpolation due to the stream suddenly pausing.\n\t */\n\tsilencePacketsRemaining: number;\n\n\t/**\n\t * The playback duration in milliseconds of the current audio resource. This includes filler silence packets\n\t * that have been played when the resource was buffering.\n\t */\n\tplaybackDuration: number;\n\n\t/**\n\t * The current resource of the audio player.\n\t */\n\tresource: AudioResource;\n\n\tonStreamError: (error: Error) => void;\n}\n\n/**\n * The various states that the player can be in.\n */\nexport type AudioPlayerState =\n\t| AudioPlayerIdleState\n\t| AudioPlayerBufferingState\n\t| AudioPlayerPlayingState\n\t| AudioPlayerPausedState;\n\nexport type AudioPlayerEvents = {\n\terror: (error: AudioPlayerError) => Awaited<void>;\n\tdebug: (message: string) => Awaited<void>;\n\tstateChange: (oldState: AudioPlayerState, newState: AudioPlayerState) => Awaited<void>;\n\tsubscribe: (subscription: PlayerSubscription) => Awaited<void>;\n\tunsubscribe: (subscription: PlayerSubscription) => Awaited<void>;\n} & {\n\t[status in AudioPlayerStatus]: (\n\t\toldState: AudioPlayerState,\n\t\tnewState: AudioPlayerState & { status: status },\n\t) => Awaited<void>;\n};\n\n/**\n * Stringifies an AudioPlayerState instance.\n *\n * @param state - The state to stringify\n */\nfunction stringifyState(state: AudioPlayerState) {\n\treturn JSON.stringify({\n\t\t...state,\n\t\tresource: Reflect.has(state, 'resource'),\n\t\tstepTimeout: Reflect.has(state, 'stepTimeout'),\n\t});\n}\n\n/**\n * Used to play audio resources (i.e. tracks, streams) to voice connections.\n *\n * @remarks\n * Audio players are designed to be re-used - even if a resource has finished playing, the player itself\n * can still be used.\n *\n * The AudioPlayer drives the timing of playback, and therefore is unaffected by voice connections\n * becoming unavailable. Its behavior in these scenarios can be configured.\n */\nexport class AudioPlayer extends TypedEmitter<AudioPlayerEvents> {\n\t/**\n\t * The state that the AudioPlayer is in.\n\t */\n\tprivate _state: AudioPlayerState;\n\n\t/**\n\t * A list of VoiceConnections that are registered to this AudioPlayer. The player will attempt to play audio\n\t * to the streams in this list.\n\t */\n\tprivate readonly subscribers: PlayerSubscription[] = [];\n\n\t/**\n\t * The behavior that the player should follow when it enters certain situations.\n\t */\n\tprivate readonly behaviors: {\n\t\tnoSubscriber: NoSubscriberBehavior;\n\t\tmaxMissedFrames: number;\n\t};\n\n\t/**\n\t * The debug logger function, if debugging is enabled.\n\t */\n\tprivate readonly debug: null | ((message: string) => void);\n\n\t/**\n\t * Creates a new AudioPlayer.\n\t */\n\tpublic constructor(options: CreateAudioPlayerOptions = {}) {\n\t\tsuper();\n\t\tthis._state = { status: AudioPlayerStatus.Idle };\n\t\tthis.behaviors = {\n\t\t\tnoSubscriber: NoSubscriberBehavior.Pause,\n\t\t\tmaxMissedFrames: 5,\n\t\t\t...options.behaviors,\n\t\t};\n\t\tthis.debug = options.debug === false ? null : (message: string) => this.emit('debug', message);\n\t}\n\n\t/**\n\t * A list of subscribed voice connections that can currently receive audio to play.\n\t */\n\tpublic get playable() {\n\t\treturn this.subscribers\n\t\t\t.filter(({ connection }) => connection.state.status === VoiceConnectionStatus.Ready)\n\t\t\t.map(({ connection }) => connection);\n\t}\n\n\t/**\n\t * Subscribes a VoiceConnection to the audio player's play list. If the VoiceConnection is already subscribed,\n\t * then the existing subscription is used.\n\t *\n\t * @remarks\n\t * This method should not be directly called. Instead, use VoiceConnection#subscribe.\n\t *\n\t * @param connection - The connection to subscribe\n\t *\n\t * @returns The new subscription if the voice connection is not yet subscribed, otherwise the existing subscription\n\t */\n\t// @ts-ignore\n\tprivate subscribe(connection: VoiceConnection) {\n\t\tconst existingSubscription = this.subscribers.find((subscription) => subscription.connection === connection);\n\t\tif (!existingSubscription) {\n\t\t\tconst subscription = new PlayerSubscription(connection, this);\n\t\t\tthis.subscribers.push(subscription);\n\t\t\tsetImmediate(() => this.emit('subscribe', subscription));\n\t\t\treturn subscription;\n\t\t}\n\t\treturn existingSubscription;\n\t}\n\n\t/**\n\t * Unsubscribes a subscription - i.e. removes a voice connection from the play list of the audio player.\n\t *\n\t * @remarks\n\t * This method should not be directly called. Instead, use PlayerSubscription#unsubscribe.\n\t *\n\t * @param subscription - The subscription to remove\n\t *\n\t * @returns Whether or not the subscription existed on the player and was removed\n\t */\n\t// @ts-ignore\n\tprivate unsubscribe(subscription: PlayerSubscription) {\n\t\tconst index = this.subscribers.indexOf(subscription);\n\t\tconst exists = index !== -1;\n\t\tif (exists) {\n\t\t\tthis.subscribers.splice(index, 1);\n\t\t\tsubscription.connection.setSpeaking(false);\n\t\t\tthis.emit('unsubscribe', subscription);\n\t\t}\n\t\treturn exists;\n\t}\n\n\t/**\n\t * The state that the player is in.\n\t */\n\tpublic get state() {\n\t\treturn this._state;\n\t}\n\n\t/**\n\t * Sets a new state for the player, performing clean-up operations where necessary.\n\t */\n\tpublic set state(newState: AudioPlayerState) {\n\t\tconst oldState = this._state;\n\t\tconst newResource = Reflect.get(newState, 'resource') as AudioResource | undefined;\n\n\t\tif (oldState.status !== AudioPlayerStatus.Idle && oldState.resource !== newResource) {\n\t\t\toldState.resource.playStream.on('error', noop);\n\t\t\toldState.resource.playStream.off('error', oldState.onStreamError);\n\t\t\toldState.resource.audioPlayer = undefined;\n\t\t\toldState.resource.playStream.destroy();\n\t\t\toldState.resource.playStream.read(); // required to ensure buffered data is drained, prevents memory leak\n\t\t}\n\n\t\t// When leaving the Buffering state (or buffering a new resource), then remove the event listeners from it\n\t\tif (\n\t\t\toldState.status === AudioPlayerStatus.Buffering &&\n\t\t\t(newState.status !== AudioPlayerStatus.Buffering || newState.resource !== oldState.resource)\n\t\t) {\n\t\t\toldState.resource.playStream.off('end', oldState.onFailureCallback);\n\t\t\toldState.resource.playStream.off('close', oldState.onFailureCallback);\n\t\t\toldState.resource.playStream.off('finish', oldState.onFailureCallback);\n\t\t\toldState.resource.playStream.off('readable', oldState.onReadableCallback);\n\t\t}\n\n\t\t// transitioning into an idle should ensure that connections stop speaking\n\t\tif (newState.status === AudioPlayerStatus.Idle) {\n\t\t\tthis._signalStopSpeaking();\n\t\t\tdeleteAudioPlayer(this);\n\t\t}\n\n\t\t// attach to the global audio player timer\n\t\tif (newResource) {\n\t\t\taddAudioPlayer(this);\n\t\t}\n\n\t\t// playing -> playing state changes should still transition if a resource changed (seems like it would be useful!)\n\t\tconst didChangeResources =\n\t\t\toldState.status !== AudioPlayerStatus.Idle &&\n\t\t\tnewState.status === AudioPlayerStatus.Playing &&\n\t\t\toldState.resource !== newState.resource;\n\n\t\tthis._state = newState;\n\n\t\tthis.emit('stateChange', oldState, this._state);\n\t\tif (oldState.status !== newState.status || didChangeResources) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n\t\t\tthis.emit(newState.status, oldState, this._state as any);\n\t\t}\n\t\tthis.debug?.(`state change:\\nfrom ${stringifyState(oldState)}\\nto ${stringifyState(newState)}`);\n\t}\n\n\t/**\n\t * Plays a new resource on the player. If the player is already playing a resource, the existing resource is destroyed\n\t * (it cannot be reused, even in another player) and is replaced with the new resource.\n\t *\n\t * @remarks\n\t * The player will transition to the Playing state once playback begins, and will return to the Idle state once\n\t * playback is ended.\n\t *\n\t * If the player was previously playing a resource and this method is called, the player will not transition to the\n\t * Idle state during the swap over.\n\t *\n\t * @param resource - The resource to play\n\t *\n\t * @throws Will throw if attempting to play an audio resource that has already ended, or is being played by another player\n\t */\n\tpublic play<T>(resource: AudioResource<T>) {\n\t\tif (resource.ended) {\n\t\t\tthrow new Error('Cannot play a resource that has already ended.');\n\t\t}\n\n\t\tif (resource.audioPlayer) {\n\t\t\tif (resource.audioPlayer === this) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthrow new Error('Resource is already being played by another audio player.');\n\t\t}\n\t\tresource.audioPlayer = this;\n\n\t\t// Attach error listeners to the stream that will propagate the error and then return to the Idle\n\t\t// state if the resource is still being used.\n\t\tconst onStreamError = (error: Error) => {\n\t\t\tif (this.state.status !== AudioPlayerStatus.Idle) {\n\t\t\t\t/**\n\t\t\t\t * Emitted when there is an error emitted from the audio resource played by the audio player\n\t\t\t\t *\n\t\t\t\t * @event AudioPlayer#error\n\t\t\t\t * @type {AudioPlayerError}\n\t\t\t\t */\n\t\t\t\tthis.emit('error', new AudioPlayerError(error, this.state.resource));\n\t\t\t}\n\n\t\t\tif (this.state.status !== AudioPlayerStatus.Idle && this.state.resource === resource) {\n\t\t\t\tthis.state = {\n\t\t\t\t\tstatus: AudioPlayerStatus.Idle,\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\n\t\tresource.playStream.once('error', onStreamError);\n\n\t\tif (resource.started) {\n\t\t\tthis.state = {\n\t\t\t\tstatus: AudioPlayerStatus.Playing,\n\t\t\t\tmissedFrames: 0,\n\t\t\t\tplaybackDuration: 0,\n\t\t\t\tresource,\n\t\t\t\tonStreamError,\n\t\t\t};\n\t\t} else {\n\t\t\tconst onReadableCallback = () => {\n\t\t\t\tif (this.state.status === AudioPlayerStatus.Buffering && this.state.resource === resource) {\n\t\t\t\t\tthis.state = {\n\t\t\t\t\t\tstatus: AudioPlayerStatus.Playing,\n\t\t\t\t\t\tmissedFrames: 0,\n\t\t\t\t\t\tplaybackDuration: 0,\n\t\t\t\t\t\tresource,\n\t\t\t\t\t\tonStreamError,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst onFailureCallback = () => {\n\t\t\t\tif (this.state.status === AudioPlayerStatus.Buffering && this.state.resource === resource) {\n\t\t\t\t\tthis.state = {\n\t\t\t\t\t\tstatus: AudioPlayerStatus.Idle,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tresource.playStream.once('readable', onReadableCallback);\n\n\t\t\tresource.playStream.once('end', onFailureCallback);\n\t\t\tresource.playStream.once('close', onFailureCallback);\n\t\t\tresource.playStream.once('finish', onFailureCallback);\n\n\t\t\tthis.state = {\n\t\t\t\tstatus: AudioPlayerStatus.Buffering,\n\t\t\t\tresource,\n\t\t\t\tonReadableCallback,\n\t\t\t\tonFailureCallback,\n\t\t\t\tonStreamError,\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * Pauses playback of the current resource, if any.\n\t *\n\t * @param interpolateSilence - If true, the player will play 5 packets of silence after pausing to prevent audio glitches\n\t *\n\t * @returns `true` if the player was successfully paused, otherwise `false`\n\t */\n\tpublic pause(interpolateSilence = true) {\n\t\tif (this.state.status !== AudioPlayerStatus.Playing) return false;\n\t\tthis.state = {\n\t\t\t...this.state,\n\t\t\tstatus: AudioPlayerStatus.Paused,\n\t\t\tsilencePacketsRemaining: interpolateSilence ? 5 : 0,\n\t\t};\n\t\treturn true;\n\t}\n\n\t/**\n\t * Unpauses playback of the current resource, if any.\n\t *\n\t * @returns `true` if the player was successfully unpaused, otherwise `false`\n\t */\n\tpublic unpause() {\n\t\tif (this.state.status !== AudioPlayerStatus.Paused) return false;\n\t\tthis.state = {\n\t\t\t...this.state,\n\t\t\tstatus: AudioPlayerStatus.Playing,\n\t\t\tmissedFrames: 0,\n\t\t};\n\t\treturn true;\n\t}\n\n\t/**\n\t * Stops playback of the current resource and destroys the resource. The player will either transition to the Idle state,\n\t * or remain in its current state until the silence padding frames of the resource have been played.\n\t *\n\t * @param force - If true, will force the player to enter the Idle state even if the resource has silence padding frames\n\t *\n\t * @returns `true` if the player will come to a stop, otherwise `false`\n\t */\n\tpublic stop(force = false) {\n\t\tif (this.state.status === AudioPlayerStatus.Idle) return false;\n\t\tif (force || this.state.resource.silencePaddingFrames === 0) {\n\t\t\tthis.state = {\n\t\t\t\tstatus: AudioPlayerStatus.Idle,\n\t\t\t};\n\t\t} else if (this.state.resource.silenceRemaining === -1) {\n\t\t\tthis.state.resource.silenceRemaining = this.state.resource.silencePaddingFrames;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Checks whether the underlying resource (if any) is playable (readable)\n\t *\n\t * @returns `true` if the resource is playable, otherwise `false`\n\t */\n\tpublic checkPlayable() {\n\t\tconst state = this._state;\n\t\tif (state.status === AudioPlayerStatus.Idle || state.status === AudioPlayerStatus.Buffering) return false;\n\n\t\t// If the stream has been destroyed or is no longer readable, then transition to the Idle state.\n\t\tif (!state.resource.readable) {\n\t\t\tthis.state = {\n\t\t\t\tstatus: AudioPlayerStatus.Idle,\n\t\t\t};\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * Called roughly every 20ms by the global audio player timer. Dispatches any audio packets that are buffered\n\t * by the active connections of this audio player.\n\t */\n\t// @ts-ignore\n\tprivate _stepDispatch() {\n\t\tconst state = this._state;\n\n\t\t// Guard against the Idle state\n\t\tif (state.status === AudioPlayerStatus.Idle || state.status === AudioPlayerStatus.Buffering) return;\n\n\t\t// Dispatch any audio packets that were prepared in the previous cycle\n\t\tthis.playable.forEach((connection) => connection.dispatchAudio());\n\t}\n\n\t/**\n\t * Called roughly every 20ms by the global audio player timer. Attempts to read an audio packet from the\n\t * underlying resource of the stream, and then has all the active connections of the audio player prepare it\n\t * (encrypt it, append header data) so that it is ready to play at the start of the next cycle.\n\t */\n\t// @ts-ignore\n\tprivate _stepPrepare() {\n\t\tconst state = this._state;\n\n\t\t// Guard against the Idle state\n\t\tif (state.status === AudioPlayerStatus.Idle || state.status === AudioPlayerStatus.Buffering) return;\n\n\t\t// List of connections that can receive the packet\n\t\tconst playable = this.playable;\n\n\t\t/* If the player was previously in the AutoPaused state, check to see whether there are newly available\n\t\t   connections, allowing us to transition out of the AutoPaused state back into the Playing state */\n\t\tif (state.status === AudioPlayerStatus.AutoPaused && playable.length > 0) {\n\t\t\tthis.state = {\n\t\t\t\t...state,\n\t\t\t\tstatus: AudioPlayerStatus.Playing,\n\t\t\t\tmissedFrames: 0,\n\t\t\t};\n\t\t}\n\n\t\t/* If the player is (auto)paused, check to see whether silence packets should be played and\n\t\t   set a timeout to begin the next cycle, ending the current cycle here. */\n\t\tif (state.status === AudioPlayerStatus.Paused || state.status === AudioPlayerStatus.AutoPaused) {\n\t\t\tif (state.silencePacketsRemaining > 0) {\n\t\t\t\tstate.silencePacketsRemaining--;\n\t\t\t\tthis._preparePacket(SILENCE_FRAME, playable, state);\n\t\t\t\tif (state.silencePacketsRemaining === 0) {\n\t\t\t\t\tthis._signalStopSpeaking();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// If there are no available connections in this cycle, observe the configured \"no subscriber\" behavior.\n\t\tif (playable.length === 0) {\n\t\t\tif (this.behaviors.noSubscriber === NoSubscriberBehavior.Pause) {\n\t\t\t\tthis.state = {\n\t\t\t\t\t...state,\n\t\t\t\t\tstatus: AudioPlayerStatus.AutoPaused,\n\t\t\t\t\tsilencePacketsRemaining: 5,\n\t\t\t\t};\n\t\t\t\treturn;\n\t\t\t} else if (this.behaviors.noSubscriber === NoSubscriberBehavior.Stop) {\n\t\t\t\tthis.stop(true);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Attempt to read an Opus packet from the resource. If there isn't an available packet,\n\t\t * play a silence packet. If there are 5 consecutive cycles with failed reads, then the\n\t\t * playback will end.\n\t\t */\n\t\tconst packet: Buffer | null = state.resource.read();\n\n\t\t// eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\t\tif (state.status === AudioPlayerStatus.Playing) {\n\t\t\tif (packet) {\n\t\t\t\tthis._preparePacket(packet, playable, state);\n\t\t\t\tstate.missedFrames = 0;\n\t\t\t} else {\n\t\t\t\tthis._preparePacket(SILENCE_FRAME, playable, state);\n\t\t\t\tstate.missedFrames++;\n\t\t\t\tif (state.missedFrames >= this.behaviors.maxMissedFrames) {\n\t\t\t\t\tthis.stop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Signals to all the subscribed connections that they should send a packet to Discord indicating\n\t * they are no longer speaking. Called once playback of a resource ends.\n\t */\n\tprivate _signalStopSpeaking() {\n\t\treturn this.subscribers.forEach(({ connection }) => connection.setSpeaking(false));\n\t}\n\n\t/**\n\t * Instructs the given connections to each prepare this packet to be played at the start of the\n\t * next cycle.\n\t *\n\t * @param packet - The Opus packet to be prepared by each receiver\n\t * @param receivers - The connections that should play this packet\n\t */\n\tprivate _preparePacket(\n\t\tpacket: Buffer,\n\t\treceivers: VoiceConnection[],\n\t\tstate: AudioPlayerPlayingState | AudioPlayerPausedState,\n\t) {\n\t\tstate.playbackDuration += 20;\n\t\treceivers.forEach((connection) => connection.prepareAudioPacket(packet));\n\t}\n}\n\n/**\n * Creates a new AudioPlayer to be used.\n */\nexport function createAudioPlayer(options?: CreateAudioPlayerOptions) {\n\treturn new AudioPlayer(options);\n}\n","import { TypedEmitter } from 'tiny-typed-emitter';\nimport type { Awaited } from '../util/util';\n\n/**\n * The events that a SpeakingMap can emit.\n */\nexport interface SpeakingMapEvents {\n\t/**\n\t * Emitted when a user starts speaking.\n\t */\n\tstart: (userId: string) => Awaited<void>;\n\n\t/**\n\t * Emitted when a user stops speaking.\n\t */\n\tend: (userId: string) => Awaited<void>;\n}\n\n/**\n * Tracks the speaking states of users in a voice channel.\n */\nexport class SpeakingMap extends TypedEmitter<SpeakingMapEvents> {\n\t/**\n\t * The delay after a packet is received from a user until they're marked as not speaking anymore.\n\t */\n\tpublic static readonly DELAY = 100;\n\n\t/**\n\t * The currently speaking users, mapped to the milliseconds since UNIX epoch at which they started speaking.\n\t */\n\tpublic readonly users: Map<string, number>;\n\n\tprivate readonly speakingTimeouts: Map<string, NodeJS.Timeout>;\n\n\tpublic constructor() {\n\t\tsuper();\n\t\tthis.users = new Map();\n\t\tthis.speakingTimeouts = new Map();\n\t}\n\n\tpublic onPacket(userId: string) {\n\t\tconst timeout = this.speakingTimeouts.get(userId);\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout);\n\t\t} else {\n\t\t\tthis.users.set(userId, Date.now());\n\t\t\tthis.emit('start', userId);\n\t\t}\n\t\tthis.startTimeout(userId);\n\t}\n\n\tprivate startTimeout(userId: string) {\n\t\tthis.speakingTimeouts.set(\n\t\t\tuserId,\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis.emit('end', userId);\n\t\t\t\tthis.speakingTimeouts.delete(userId);\n\t\t\t\tthis.users.delete(userId);\n\t\t\t}, SpeakingMap.DELAY),\n\t\t);\n\t}\n}\n","import { TypedEmitter } from 'tiny-typed-emitter';\nimport type { Awaited } from '../util/util';\n\n/**\n * The known data for a user in a Discord voice connection.\n */\nexport interface VoiceUserData {\n\t/**\n\t * The SSRC of the user's audio stream.\n\t */\n\taudioSSRC: number;\n\n\t/**\n\t * The SSRC of the user's video stream (if one exists)\n\t * Cannot be 0. If undefined, the user has no video stream.\n\t */\n\tvideoSSRC?: number;\n\n\t/**\n\t * The Discord user id of the user.\n\t */\n\tuserId: string;\n}\n\n/**\n * The events that an SSRCMap may emit.\n */\nexport interface SSRCMapEvents {\n\tcreate: (newData: VoiceUserData) => Awaited<void>;\n\tupdate: (oldData: VoiceUserData | undefined, newData: VoiceUserData) => Awaited<void>;\n\tdelete: (deletedData: VoiceUserData) => Awaited<void>;\n}\n\n/**\n * Maps audio SSRCs to data of users in voice connections.\n */\nexport class SSRCMap extends TypedEmitter<SSRCMapEvents> {\n\t/**\n\t * The underlying map.\n\t */\n\tprivate readonly map: Map<number, VoiceUserData>;\n\n\tpublic constructor() {\n\t\tsuper();\n\t\tthis.map = new Map();\n\t}\n\n\t/**\n\t * Updates the map with new user data\n\t *\n\t * @param data The data to update with\n\t */\n\tpublic update(data: VoiceUserData) {\n\t\tconst existing = this.map.get(data.audioSSRC);\n\n\t\tconst newValue = {\n\t\t\t...this.map.get(data.audioSSRC),\n\t\t\t...data,\n\t\t};\n\n\t\tthis.map.set(data.audioSSRC, newValue);\n\t\tif (!existing) this.emit('create', newValue);\n\t\tthis.emit('update', existing, newValue);\n\t}\n\n\t/**\n\t * Gets the stored voice data of a user.\n\t *\n\t * @param target The target, either their user id or audio SSRC\n\t */\n\tpublic get(target: number | string) {\n\t\tif (typeof target === 'number') {\n\t\t\treturn this.map.get(target);\n\t\t}\n\n\t\tfor (const data of this.map.values()) {\n\t\t\tif (data.userId === target) {\n\t\t\t\treturn data;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Deletes the stored voice data about a user.\n\t *\n\t * @param target The target of the delete operation, either their audio SSRC or user id\n\t *\n\t * @returns The data that was deleted, if any\n\t */\n\tpublic delete(target: number | string) {\n\t\tif (typeof target === 'number') {\n\t\t\tconst existing = this.map.get(target);\n\t\t\tif (existing) {\n\t\t\t\tthis.map.delete(target);\n\t\t\t\tthis.emit('delete', existing);\n\t\t\t}\n\t\t\treturn existing;\n\t\t}\n\n\t\tfor (const [audioSSRC, data] of this.map.entries()) {\n\t\t\tif (data.userId === target) {\n\t\t\t\tthis.map.delete(audioSSRC);\n\t\t\t\tthis.emit('delete', data);\n\t\t\t\treturn data;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n}\n","import { createVoiceConnection } from './VoiceConnection';\nimport type { JoinConfig } from './DataStore';\nimport type { DiscordGatewayAdapterCreator } from './util/adapter';\n\n/**\n * The options that can be given when creating a voice connection.\n */\nexport interface CreateVoiceConnectionOptions {\n\t/**\n\t * If true, debug messages will be enabled for the voice connection and its\n\t * related components. Defaults to false.\n\t */\n\tdebug?: boolean;\n\n\tadapterCreator: DiscordGatewayAdapterCreator;\n}\n\n/**\n * The options that can be given when joining a voice channel.\n */\nexport interface JoinVoiceChannelOptions {\n\t/**\n\t * The id of the Discord voice channel to join.\n\t */\n\tchannelId: string;\n\n\t/**\n\t * The id of the guild that the voice channel belongs to.\n\t */\n\tguildId: string;\n\n\t/**\n\t * Whether to join the channel deafened (defaults to true)\n\t */\n\tselfDeaf?: boolean;\n\n\t/**\n\t * Whether to join the channel muted (defaults to true)\n\t */\n\tselfMute?: boolean;\n\n\t/**\n\t * An optional group identifier for the voice connection.\n\t */\n\tgroup?: string;\n}\n\n/**\n * Creates a VoiceConnection to a Discord voice channel.\n *\n * @param voiceChannel - the voice channel to connect to\n * @param options - the options for joining the voice channel\n */\nexport function joinVoiceChannel(options: JoinVoiceChannelOptions & CreateVoiceConnectionOptions) {\n\tconst joinConfig: JoinConfig = {\n\t\tselfDeaf: true,\n\t\tselfMute: false,\n\t\tgroup: 'default',\n\t\t...options,\n\t};\n\n\treturn createVoiceConnection(joinConfig, {\n\t\tadapterCreator: options.adapterCreator,\n\t\tdebug: options.debug,\n\t});\n}\n","import type { Readable } from 'node:stream';\nimport prism from 'prism-media';\n\n/**\n * This module creates a Transformer Graph to figure out what the most efficient way\n * of transforming the input stream into something playable would be.\n */\n\nconst FFMPEG_PCM_ARGUMENTS = ['-analyzeduration', '0', '-loglevel', '0', '-f', 's16le', '-ar', '48000', '-ac', '2'];\nconst FFMPEG_OPUS_ARGUMENTS = [\n\t'-analyzeduration',\n\t'0',\n\t'-loglevel',\n\t'0',\n\t'-acodec',\n\t'libopus',\n\t'-f',\n\t'opus',\n\t'-ar',\n\t'48000',\n\t'-ac',\n\t'2',\n];\n\n/**\n * The different types of stream that can exist within the pipeline.\n *\n * @remarks\n * - `Arbitrary` - the type of the stream at this point is unknown.\n * - `Raw` - the stream at this point is s16le PCM.\n * - `OggOpus` - the stream at this point is Opus audio encoded in an Ogg wrapper.\n * - `WebmOpus` - the stream at this point is Opus audio encoded in a WebM wrapper.\n * - `Opus` - the stream at this point is Opus audio, and the stream is in object-mode. This is ready to play.\n */\nexport enum StreamType {\n\tArbitrary = 'arbitrary',\n\tRaw = 'raw',\n\tOggOpus = 'ogg/opus',\n\tWebmOpus = 'webm/opus',\n\tOpus = 'opus',\n}\n\n/**\n * The different types of transformers that can exist within the pipeline.\n */\nexport enum TransformerType {\n\tFFmpegPCM = 'ffmpeg pcm',\n\tFFmpegOgg = 'ffmpeg ogg',\n\tOpusEncoder = 'opus encoder',\n\tOpusDecoder = 'opus decoder',\n\tOggOpusDemuxer = 'ogg/opus demuxer',\n\tWebmOpusDemuxer = 'webm/opus demuxer',\n\tInlineVolume = 'volume transformer',\n}\n\n/**\n * Represents a pathway from one stream type to another using a transformer.\n */\nexport interface Edge {\n\tfrom: Node;\n\tto: Node;\n\tcost: number;\n\ttransformer: (input: string | Readable) => Readable;\n\ttype: TransformerType;\n}\n\n/**\n * Represents a type of stream within the graph, e.g. an Opus stream, or a stream of raw audio.\n */\nexport class Node {\n\t/**\n\t * The outbound edges from this node.\n\t */\n\tpublic readonly edges: Edge[] = [];\n\n\t/**\n\t * The type of stream for this node.\n\t */\n\tpublic readonly type: StreamType;\n\n\tpublic constructor(type: StreamType) {\n\t\tthis.type = type;\n\t}\n\n\t/**\n\t * Creates an outbound edge from this node.\n\t *\n\t * @param edge - The edge to create\n\t */\n\tpublic addEdge(edge: Omit<Edge, 'from'>) {\n\t\tthis.edges.push({ ...edge, from: this });\n\t}\n}\n\n// Create a node for each stream type\nconst NODES = new Map<StreamType, Node>();\nfor (const streamType of Object.values(StreamType)) {\n\tNODES.set(streamType, new Node(streamType));\n}\n\n/**\n * Gets a node from its stream type.\n *\n * @param type - The stream type of the target node\n */\nexport function getNode(type: StreamType) {\n\tconst node = NODES.get(type);\n\tif (!node) throw new Error(`Node type '${type}' does not exist!`);\n\treturn node;\n}\n\ngetNode(StreamType.Raw).addEdge({\n\ttype: TransformerType.OpusEncoder,\n\tto: getNode(StreamType.Opus),\n\tcost: 1.5,\n\ttransformer: () => new prism.opus.Encoder({ rate: 48000, channels: 2, frameSize: 960 }),\n});\n\ngetNode(StreamType.Opus).addEdge({\n\ttype: TransformerType.OpusDecoder,\n\tto: getNode(StreamType.Raw),\n\tcost: 1.5,\n\ttransformer: () => new prism.opus.Decoder({ rate: 48000, channels: 2, frameSize: 960 }),\n});\n\ngetNode(StreamType.OggOpus).addEdge({\n\ttype: TransformerType.OggOpusDemuxer,\n\tto: getNode(StreamType.Opus),\n\tcost: 1,\n\ttransformer: () => new prism.opus.OggDemuxer(),\n});\n\ngetNode(StreamType.WebmOpus).addEdge({\n\ttype: TransformerType.WebmOpusDemuxer,\n\tto: getNode(StreamType.Opus),\n\tcost: 1,\n\ttransformer: () => new prism.opus.WebmDemuxer(),\n});\n\nconst FFMPEG_PCM_EDGE: Omit<Edge, 'from'> = {\n\ttype: TransformerType.FFmpegPCM,\n\tto: getNode(StreamType.Raw),\n\tcost: 2,\n\ttransformer: (input) =>\n\t\tnew prism.FFmpeg({\n\t\t\targs: typeof input === 'string' ? ['-i', input, ...FFMPEG_PCM_ARGUMENTS] : FFMPEG_PCM_ARGUMENTS,\n\t\t}),\n};\n\ngetNode(StreamType.Arbitrary).addEdge(FFMPEG_PCM_EDGE);\ngetNode(StreamType.OggOpus).addEdge(FFMPEG_PCM_EDGE);\ngetNode(StreamType.WebmOpus).addEdge(FFMPEG_PCM_EDGE);\n\ngetNode(StreamType.Raw).addEdge({\n\ttype: TransformerType.InlineVolume,\n\tto: getNode(StreamType.Raw),\n\tcost: 0.5,\n\ttransformer: () => new prism.VolumeTransformer({ type: 's16le' }),\n});\n\n// Try to enable FFmpeg Ogg optimizations\nfunction canEnableFFmpegOptimizations(): boolean {\n\ttry {\n\t\treturn prism.FFmpeg.getInfo().output.includes('--enable-libopus');\n\t} catch {}\n\treturn false;\n}\n\nif (canEnableFFmpegOptimizations()) {\n\tconst FFMPEG_OGG_EDGE: Omit<Edge, 'from'> = {\n\t\ttype: TransformerType.FFmpegOgg,\n\t\tto: getNode(StreamType.OggOpus),\n\t\tcost: 2,\n\t\ttransformer: (input) =>\n\t\t\tnew prism.FFmpeg({\n\t\t\t\targs: typeof input === 'string' ? ['-i', input, ...FFMPEG_OPUS_ARGUMENTS] : FFMPEG_OPUS_ARGUMENTS,\n\t\t\t}),\n\t};\n\tgetNode(StreamType.Arbitrary).addEdge(FFMPEG_OGG_EDGE);\n\t// Include Ogg and WebM as well in case they have different sampling rates or are mono instead of stereo\n\t// at the moment, this will not do anything. However, if/when detection for correct Opus headers is\n\t// implemented, this will help inform the voice engine that it is able to transcode the audio.\n\tgetNode(StreamType.OggOpus).addEdge(FFMPEG_OGG_EDGE);\n\tgetNode(StreamType.WebmOpus).addEdge(FFMPEG_OGG_EDGE);\n}\n\n/**\n * Represents a step in the path from node A to node B.\n */\ninterface Step {\n\t/**\n\t * The next step.\n\t */\n\tnext?: Step;\n\n\t/**\n\t * The cost of the steps after this step.\n\t */\n\tcost: number;\n\n\t/**\n\t * The edge associated with this step.\n\t */\n\tedge?: Edge;\n}\n\n/**\n * Finds the shortest cost path from node A to node B.\n *\n * @param from - The start node\n * @param constraints - Extra validation for a potential solution. Takes a path, returns true if the path is valid\n * @param goal - The target node\n * @param path - The running path\n * @param depth - The number of remaining recursions\n */\nfunction findPath(\n\tfrom: Node,\n\tconstraints: (path: Edge[]) => boolean,\n\tgoal = getNode(StreamType.Opus),\n\tpath: Edge[] = [],\n\tdepth = 5,\n): Step {\n\tif (from === goal && constraints(path)) {\n\t\treturn { cost: 0 };\n\t} else if (depth === 0) {\n\t\treturn { cost: Infinity };\n\t}\n\n\tlet currentBest: Step | undefined = undefined;\n\tfor (const edge of from.edges) {\n\t\tif (currentBest && edge.cost > currentBest.cost) continue;\n\t\tconst next = findPath(edge.to, constraints, goal, [...path, edge], depth - 1);\n\t\tconst cost = edge.cost + next.cost;\n\t\tif (!currentBest || cost < currentBest.cost) {\n\t\t\tcurrentBest = { cost, edge, next };\n\t\t}\n\t}\n\treturn currentBest ?? { cost: Infinity };\n}\n\n/**\n * Takes the solution from findPath and assembles it into a list of edges.\n *\n * @param step - The first step of the path\n */\nfunction constructPipeline(step: Step) {\n\tconst edges = [];\n\tlet current: Step | undefined = step;\n\twhile (current?.edge) {\n\t\tedges.push(current.edge);\n\t\tcurrent = current.next;\n\t}\n\treturn edges;\n}\n\n/**\n * Finds the lowest-cost pipeline to convert the input stream type into an Opus stream.\n *\n * @param from - The stream type to start from\n * @param constraint - Extra constraints that may be imposed on potential solution\n */\nexport function findPipeline(from: StreamType, constraint: (path: Edge[]) => boolean) {\n\treturn constructPipeline(findPath(getNode(from), constraint));\n}\n","import { Edge, findPipeline, StreamType, TransformerType } from './TransformerGraph';\nimport { pipeline, Readable } from 'node:stream';\nimport { noop } from '../util/util';\nimport prism from 'prism-media';\nimport { AudioPlayer, SILENCE_FRAME } from './AudioPlayer';\n\n/**\n * Options that are set when creating a new audio resource.\n *\n * @template T - the type for the metadata (if any) of the audio resource\n */\nexport interface CreateAudioResourceOptions<T> {\n\t/**\n\t * The type of the input stream. Defaults to `StreamType.Arbitrary`.\n\t */\n\tinputType?: StreamType;\n\n\t/**\n\t * Optional metadata that can be attached to the resource (e.g. track title, random id).\n\t * This is useful for identification purposes when the resource is passed around in events.\n\t * See {@link AudioResource.metadata}\n\t */\n\tmetadata?: T;\n\n\t/**\n\t * Whether or not inline volume should be enabled. If enabled, you will be able to change the volume\n\t * of the stream on-the-fly. However, this also increases the performance cost of playback. Defaults to `false`.\n\t */\n\tinlineVolume?: boolean;\n\n\t/**\n\t * The number of silence frames to append to the end of the resource's audio stream, to prevent interpolation glitches.\n\t * Defaults to 5.\n\t */\n\tsilencePaddingFrames?: number;\n}\n\n/**\n * Represents an audio resource that can be played by an audio player.\n *\n * @template T - the type for the metadata (if any) of the audio resource\n */\nexport class AudioResource<T = unknown> {\n\t/**\n\t * An object-mode Readable stream that emits Opus packets. This is what is played by audio players.\n\t */\n\tpublic readonly playStream: Readable;\n\n\t/**\n\t * The pipeline used to convert the input stream into a playable format. For example, this may\n\t * contain an FFmpeg component for arbitrary inputs, and it may contain a VolumeTransformer component\n\t * for resources with inline volume transformation enabled.\n\t */\n\tpublic readonly edges: readonly Edge[];\n\n\t/**\n\t * Optional metadata that can be used to identify the resource.\n\t */\n\tpublic metadata: T;\n\n\t/**\n\t * If the resource was created with inline volume transformation enabled, then this will be a\n\t * prism-media VolumeTransformer. You can use this to alter the volume of the stream.\n\t */\n\tpublic readonly volume?: prism.VolumeTransformer;\n\n\t/**\n\t * If using an Opus encoder to create this audio resource, then this will be a prism-media opus.Encoder.\n\t * You can use this to control settings such as bitrate, FEC, PLP.\n\t */\n\tpublic readonly encoder?: prism.opus.Encoder;\n\n\t/**\n\t * The audio player that the resource is subscribed to, if any.\n\t */\n\tpublic audioPlayer?: AudioPlayer;\n\n\t/**\n\t * The playback duration of this audio resource, given in milliseconds.\n\t */\n\tpublic playbackDuration = 0;\n\n\t/**\n\t * Whether or not the stream for this resource has started (data has become readable)\n\t */\n\tpublic started = false;\n\n\t/**\n\t * The number of silence frames to append to the end of the resource's audio stream, to prevent interpolation glitches.\n\t */\n\tpublic readonly silencePaddingFrames: number;\n\n\t/**\n\t * The number of remaining silence frames to play. If -1, the frames have not yet started playing.\n\t */\n\tpublic silenceRemaining = -1;\n\n\tpublic constructor(edges: readonly Edge[], streams: readonly Readable[], metadata: T, silencePaddingFrames: number) {\n\t\tthis.edges = edges;\n\t\tthis.playStream = streams.length > 1 ? (pipeline(streams, noop) as any as Readable) : streams[0];\n\t\tthis.metadata = metadata;\n\t\tthis.silencePaddingFrames = silencePaddingFrames;\n\n\t\tfor (const stream of streams) {\n\t\t\tif (stream instanceof prism.VolumeTransformer) {\n\t\t\t\tthis.volume = stream;\n\t\t\t} else if (stream instanceof prism.opus.Encoder) {\n\t\t\t\tthis.encoder = stream;\n\t\t\t}\n\t\t}\n\n\t\tthis.playStream.once('readable', () => (this.started = true));\n\t}\n\n\t/**\n\t * Whether this resource is readable. If the underlying resource is no longer readable, this will still return true\n\t * while there are silence padding frames left to play.\n\t */\n\tpublic get readable() {\n\t\tif (this.silenceRemaining === 0) return false;\n\t\tconst real = this.playStream.readable;\n\t\tif (!real) {\n\t\t\tif (this.silenceRemaining === -1) this.silenceRemaining = this.silencePaddingFrames;\n\t\t\treturn this.silenceRemaining !== 0;\n\t\t}\n\t\treturn real;\n\t}\n\n\t/**\n\t * Whether this resource has ended or not.\n\t */\n\tpublic get ended() {\n\t\treturn this.playStream.readableEnded || this.playStream.destroyed || this.silenceRemaining === 0;\n\t}\n\n\t/**\n\t * Attempts to read an Opus packet from the audio resource. If a packet is available, the playbackDuration\n\t * is incremented.\n\t *\n\t * @remarks\n\t * It is advisable to check that the playStream is readable before calling this method. While no runtime\n\t * errors will be thrown, you should check that the resource is still available before attempting to\n\t * read from it.\n\t *\n\t * @internal\n\t */\n\tpublic read(): Buffer | null {\n\t\tif (this.silenceRemaining === 0) {\n\t\t\treturn null;\n\t\t} else if (this.silenceRemaining > 0) {\n\t\t\tthis.silenceRemaining--;\n\t\t\treturn SILENCE_FRAME;\n\t\t}\n\t\tconst packet = this.playStream.read() as Buffer | null;\n\t\tif (packet) {\n\t\t\tthis.playbackDuration += 20;\n\t\t}\n\t\treturn packet;\n\t}\n}\n\n/**\n * Ensures that a path contains at least one volume transforming component.\n *\n * @param path - The path to validate constraints on\n */\nexport const VOLUME_CONSTRAINT = (path: Edge[]) => path.some((edge) => edge.type === TransformerType.InlineVolume);\n\nexport const NO_CONSTRAINT = () => true;\n\n/**\n * Tries to infer the type of a stream to aid with transcoder pipelining.\n *\n * @param stream - The stream to infer the type of\n */\nexport function inferStreamType(stream: Readable): {\n\tstreamType: StreamType;\n\thasVolume: boolean;\n} {\n\tif (stream instanceof prism.opus.Encoder) {\n\t\treturn { streamType: StreamType.Opus, hasVolume: false };\n\t} else if (stream instanceof prism.opus.Decoder) {\n\t\treturn { streamType: StreamType.Raw, hasVolume: false };\n\t} else if (stream instanceof prism.VolumeTransformer) {\n\t\treturn { streamType: StreamType.Raw, hasVolume: true };\n\t} else if (stream instanceof prism.opus.OggDemuxer) {\n\t\treturn { streamType: StreamType.Opus, hasVolume: false };\n\t} else if (stream instanceof prism.opus.WebmDemuxer) {\n\t\treturn { streamType: StreamType.Opus, hasVolume: false };\n\t}\n\treturn { streamType: StreamType.Arbitrary, hasVolume: false };\n}\n\n/**\n * Creates an audio resource that can be played by audio players.\n *\n * @remarks\n * If the input is given as a string, then the inputType option will be overridden and FFmpeg will be used.\n *\n * If the input is not in the correct format, then a pipeline of transcoders and transformers will be created\n * to ensure that the resultant stream is in the correct format for playback. This could involve using FFmpeg,\n * Opus transcoders, and Ogg/WebM demuxers.\n *\n * @param input - The resource to play\n * @param options - Configurable options for creating the resource\n *\n * @template T - the type for the metadata (if any) of the audio resource\n */\nexport function createAudioResource<T>(\n\tinput: string | Readable,\n\toptions: CreateAudioResourceOptions<T> &\n\t\tPick<\n\t\t\tT extends null | undefined ? CreateAudioResourceOptions<T> : Required<CreateAudioResourceOptions<T>>,\n\t\t\t'metadata'\n\t\t>,\n): AudioResource<T extends null | undefined ? null : T>;\n\n/**\n * Creates an audio resource that can be played by audio players.\n *\n * @remarks\n * If the input is given as a string, then the inputType option will be overridden and FFmpeg will be used.\n *\n * If the input is not in the correct format, then a pipeline of transcoders and transformers will be created\n * to ensure that the resultant stream is in the correct format for playback. This could involve using FFmpeg,\n * Opus transcoders, and Ogg/WebM demuxers.\n *\n * @param input - The resource to play\n * @param options - Configurable options for creating the resource\n *\n * @template T - the type for the metadata (if any) of the audio resource\n */\nexport function createAudioResource<T extends null | undefined>(\n\tinput: string | Readable,\n\toptions?: Omit<CreateAudioResourceOptions<T>, 'metadata'>,\n): AudioResource<null>;\n\n/**\n * Creates an audio resource that can be played by audio players.\n *\n * @remarks\n * If the input is given as a string, then the inputType option will be overridden and FFmpeg will be used.\n *\n * If the input is not in the correct format, then a pipeline of transcoders and transformers will be created\n * to ensure that the resultant stream is in the correct format for playback. This could involve using FFmpeg,\n * Opus transcoders, and Ogg/WebM demuxers.\n *\n * @param input - The resource to play\n * @param options - Configurable options for creating the resource\n *\n * @template T - the type for the metadata (if any) of the audio resource\n */\nexport function createAudioResource<T>(\n\tinput: string | Readable,\n\toptions: CreateAudioResourceOptions<T> = {},\n): AudioResource<T> {\n\tlet inputType = options.inputType;\n\tlet needsInlineVolume = Boolean(options.inlineVolume);\n\n\t// string inputs can only be used with FFmpeg\n\tif (typeof input === 'string') {\n\t\tinputType = StreamType.Arbitrary;\n\t} else if (typeof inputType === 'undefined') {\n\t\tconst analysis = inferStreamType(input);\n\t\tinputType = analysis.streamType;\n\t\tneedsInlineVolume = needsInlineVolume && !analysis.hasVolume;\n\t}\n\n\tconst transformerPipeline = findPipeline(inputType, needsInlineVolume ? VOLUME_CONSTRAINT : NO_CONSTRAINT);\n\n\tif (transformerPipeline.length === 0) {\n\t\tif (typeof input === 'string') throw new Error(`Invalid pipeline constructed for string resource '${input}'`);\n\t\t// No adjustments required\n\t\treturn new AudioResource<T>([], [input], (options.metadata ?? null) as T, options.silencePaddingFrames ?? 5);\n\t}\n\tconst streams = transformerPipeline.map((edge) => edge.transformer(input));\n\tif (typeof input !== 'string') streams.unshift(input);\n\n\treturn new AudioResource<T>(\n\t\ttransformerPipeline,\n\t\tstreams,\n\t\t(options.metadata ?? null) as T,\n\t\toptions.silencePaddingFrames ?? 5,\n\t);\n}\n","/* eslint-disable @typescript-eslint/no-var-requires */\n/* eslint-disable @typescript-eslint/no-require-imports */\nimport { resolve, dirname } from 'node:path';\nimport prism from 'prism-media';\n\n/**\n * Tries to find the package.json file for a given module.\n *\n * @param dir - The directory to look in\n * @param packageName - The name of the package to look for\n * @param depth - The maximum recursion depth\n */\nfunction findPackageJSON(\n\tdir: string,\n\tpackageName: string,\n\tdepth: number,\n): { name: string; version: string } | undefined {\n\tif (depth === 0) return undefined;\n\tconst attemptedPath = resolve(dir, './package.json');\n\ttry {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\t\tconst pkg = require(attemptedPath);\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n\t\tif (pkg.name !== packageName) throw new Error('package.json does not match');\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-return\n\t\treturn pkg;\n\t} catch (err) {\n\t\treturn findPackageJSON(resolve(dir, '..'), packageName, depth - 1);\n\t}\n}\n\n/**\n * Tries to find the version of a dependency.\n *\n * @param name - The package to find the version of\n */\nfunction version(name: string): string {\n\ttry {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\t\tconst pkg =\n\t\t\tname === '@discordjs/voice'\n\t\t\t\t? require('../../package.json')\n\t\t\t\t: findPackageJSON(dirname(require.resolve(name)), name, 3);\n\t\t// eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access\n\t\treturn pkg?.version ?? 'not found';\n\t} catch (err) {\n\t\treturn 'not found';\n\t}\n}\n\n/**\n * Generates a report of the dependencies used by the \\@discordjs/voice module.\n * Useful for debugging.\n */\nexport function generateDependencyReport() {\n\tconst report = [];\n\tconst addVersion = (name: string) => report.push(`- ${name}: ${version(name)}`);\n\t// general\n\treport.push('Core Dependencies');\n\taddVersion('@discordjs/voice');\n\taddVersion('prism-media');\n\treport.push('');\n\n\t// opus\n\treport.push('Opus Libraries');\n\taddVersion('@discordjs/opus');\n\taddVersion('opusscript');\n\treport.push('');\n\n\t// encryption\n\treport.push('Encryption Libraries');\n\taddVersion('sodium');\n\taddVersion('libsodium-wrappers');\n\taddVersion('tweetnacl');\n\treport.push('');\n\n\t// ffmpeg\n\treport.push('FFmpeg');\n\ttry {\n\t\tconst info = prism.FFmpeg.getInfo();\n\t\treport.push(`- version: ${info.version}`);\n\t\treport.push(`- libopus: ${info.output.includes('--enable-libopus') ? 'yes' : 'no'}`);\n\t} catch (err) {\n\t\treport.push('- not found');\n\t}\n\n\treturn ['-'.repeat(50), ...report, '-'.repeat(50)].join('\\n');\n}\n","/**\n * Creates an abort controller that aborts after the given time.\n *\n * @param delay - The time in milliseconds to wait before aborting\n */\nexport function abortAfter(delay: number): [AbortController, AbortSignal] {\n\tconst ac = new AbortController();\n\tconst timeout = setTimeout(() => ac.abort(), delay);\n\t// @ts-expect-error\n\t// eslint-disable-next-line @typescript-eslint/no-unsafe-call\n\tac.signal.addEventListener('abort', () => clearTimeout(timeout));\n\treturn [ac, ac.signal];\n}\n","import type { VoiceConnection, VoiceConnectionStatus } from '../VoiceConnection';\nimport type { AudioPlayer, AudioPlayerStatus } from '../audio/AudioPlayer';\nimport { abortAfter } from './abortAfter';\nimport EventEmitter, { once } from 'node:events';\n\n/**\n * Allows a voice connection a specified amount of time to enter a given state, otherwise rejects with an error.\n *\n * @param target - The voice connection that we want to observe the state change for\n * @param status - The status that the voice connection should be in\n * @param timeoutOrSignal - The maximum time we are allowing for this to occur, or a signal that will abort the operation\n */\nexport function entersState(\n\ttarget: VoiceConnection,\n\tstatus: VoiceConnectionStatus,\n\ttimeoutOrSignal: number | AbortSignal,\n): Promise<VoiceConnection>;\n\n/**\n * Allows an audio player a specified amount of time to enter a given state, otherwise rejects with an error.\n *\n * @param target - The audio player that we want to observe the state change for\n * @param status - The status that the audio player should be in\n * @param timeoutOrSignal - The maximum time we are allowing for this to occur, or a signal that will abort the operation\n */\nexport function entersState(\n\ttarget: AudioPlayer,\n\tstatus: AudioPlayerStatus,\n\ttimeoutOrSignal: number | AbortSignal,\n): Promise<AudioPlayer>;\n\n/**\n * Allows a target a specified amount of time to enter a given state, otherwise rejects with an error.\n *\n * @param target - The object that we want to observe the state change for\n * @param status - The status that the target should be in\n * @param timeoutOrSignal - The maximum time we are allowing for this to occur, or a signal that will abort the operation\n */\nexport async function entersState<T extends VoiceConnection | AudioPlayer>(\n\ttarget: T,\n\tstatus: VoiceConnectionStatus | AudioPlayerStatus,\n\ttimeoutOrSignal: number | AbortSignal,\n) {\n\tif (target.state.status !== status) {\n\t\tconst [ac, signal] =\n\t\t\ttypeof timeoutOrSignal === 'number' ? abortAfter(timeoutOrSignal) : [undefined, timeoutOrSignal];\n\t\ttry {\n\t\t\tawait once(target as EventEmitter, status, { signal });\n\t\t} finally {\n\t\t\tac?.abort();\n\t\t}\n\t}\n\treturn target;\n}\n","import { Readable } from 'node:stream';\nimport prism from 'prism-media';\nimport { noop } from './util';\nimport { StreamType } from '..';\n\n/**\n * Takes an Opus Head, and verifies whether the associated Opus audio is suitable to play in a Discord voice channel.\n *\n * @param opusHead The Opus Head to validate\n *\n * @returns `true` if suitable to play in a Discord voice channel, otherwise `false`\n */\nexport function validateDiscordOpusHead(opusHead: Buffer): boolean {\n\tconst channels = opusHead.readUInt8(9);\n\tconst sampleRate = opusHead.readUInt32LE(12);\n\treturn channels === 2 && sampleRate === 48000;\n}\n\n/**\n * The resulting information after probing an audio stream\n */\nexport interface ProbeInfo {\n\t/**\n\t * The readable audio stream to use. You should use this rather than the input stream, as the probing\n\t * function can sometimes read the input stream to its end and cause the stream to close.\n\t */\n\tstream: Readable;\n\n\t/**\n\t * The recommended stream type for this audio stream.\n\t */\n\ttype: StreamType;\n}\n\n/**\n * Attempt to probe a readable stream to figure out whether it can be demuxed using an Ogg or WebM Opus demuxer.\n *\n * @param stream The readable stream to probe\n * @param probeSize The number of bytes to attempt to read before giving up on the probe\n * @param validator The Opus Head validator function\n *\n * @experimental\n */\nexport function demuxProbe(\n\tstream: Readable,\n\tprobeSize = 1024,\n\tvalidator = validateDiscordOpusHead,\n): Promise<ProbeInfo> {\n\treturn new Promise((resolve, reject) => {\n\t\t// Preconditions\n\t\tif (stream.readableObjectMode) return reject(new Error('Cannot probe a readable stream in object mode'));\n\t\tif (stream.readableEnded) return reject(new Error('Cannot probe a stream that has ended'));\n\n\t\tlet readBuffer = Buffer.alloc(0);\n\n\t\tlet resolved: StreamType | undefined = undefined;\n\n\t\tconst finish = (type: StreamType) => {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-use-before-define\n\t\t\tstream.off('data', onData);\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-use-before-define\n\t\t\tstream.off('close', onClose);\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-use-before-define\n\t\t\tstream.off('end', onClose);\n\t\t\tstream.pause();\n\t\t\tresolved = type;\n\t\t\tif (stream.readableEnded) {\n\t\t\t\tresolve({\n\t\t\t\t\tstream: Readable.from(readBuffer),\n\t\t\t\t\ttype,\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (readBuffer.length > 0) {\n\t\t\t\t\tstream.push(readBuffer);\n\t\t\t\t}\n\t\t\t\tresolve({\n\t\t\t\t\tstream,\n\t\t\t\t\ttype,\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tconst foundHead = (type: StreamType) => (head: Buffer) => {\n\t\t\tif (validator(head)) {\n\t\t\t\tfinish(type);\n\t\t\t}\n\t\t};\n\n\t\tconst webm = new prism.opus.WebmDemuxer();\n\t\twebm.once('error', noop);\n\t\twebm.on('head', foundHead(StreamType.WebmOpus));\n\n\t\tconst ogg = new prism.opus.OggDemuxer();\n\t\togg.once('error', noop);\n\t\togg.on('head', foundHead(StreamType.OggOpus));\n\n\t\tconst onClose = () => {\n\t\t\tif (!resolved) {\n\t\t\t\tfinish(StreamType.Arbitrary);\n\t\t\t}\n\t\t};\n\n\t\tconst onData = (buffer: Buffer) => {\n\t\t\treadBuffer = Buffer.concat([readBuffer, buffer]);\n\n\t\t\twebm.write(buffer);\n\t\t\togg.write(buffer);\n\n\t\t\tif (readBuffer.length >= probeSize) {\n\t\t\t\tstream.off('data', onData);\n\t\t\t\tstream.pause();\n\t\t\t\tprocess.nextTick(onClose);\n\t\t\t}\n\t\t};\n\n\t\tstream.once('error', reject);\n\t\tstream.on('data', onData);\n\t\tstream.once('close', onClose);\n\t\tstream.once('end', onClose);\n\t});\n}\n"],"mappings":"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","names":[]}